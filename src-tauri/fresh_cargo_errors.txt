cargo :     Checking storyweaver v0.1.0 
(C:\Users\jjgor\JSG-StoryWeaver\src-tauri)
At line:1 char:1
+ cargo check 2>&1 | Out-File -FilePath "fresh_cargo_errors.txt" -Encod 
...
+ ~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (    Checking st...aver\src-t 
   auri):String) [], RemoteException
    + FullyQualifiedErrorId : NativeCommandError
 
warning: unused imports: `models::*` and `operations::*`
 --> src\commands\mod.rs:4:33
  |
4 | use crate::database::{get_pool, models::*, operations::*};
  |                                 ^^^^^^^^^  ^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `tauri::State`
 --> src\commands\mod.rs:7:5
  |
7 | use tauri::State;
  |     ^^^^^^^^^^^^

warning: unused import: `crate::commands::CommandResponse`
 --> src\commands\projects.rs:3:5
  |
3 | use crate::commands::CommandResponse;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Serialize`
 --> src\commands\story_bible.rs:6:26
  |
6 | use serde::{Deserialize, Serialize};
  |                          ^^^^^^^^^

warning: unused imports: `CharacterTrait`, `StoryBible`, `StyleExample`, 
and `WorldElement`
 --> src\commands\story_bible_ai.rs:8:31
  |
8 | use crate::database::models::{StoryBible, CharacterTrait, 
WorldElement, StyleExample};
  |                               ^^^^^^^^^^  ^^^^^^^^^^^^^^  
^^^^^^^^^^^^  ^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src\commands\story_bible_ai.rs:11:5
   |
11 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::commands::CommandResponse`
 --> src\commands\ai_history.rs:3:5
  |
3 | use crate::commands::CommandResponse;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::commands::CommandResponse`
 --> src\commands\ai_writing.rs:3:5
  |
3 | use crate::commands::CommandResponse;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::error::StoryWeaverError`
 --> src\commands\ai_writing.rs:4:5
  |
4 | use crate::error::StoryWeaverError;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `RewriteStyle`
 --> src\commands\ai_writing.rs:5:47
  |
5 | use crate::ai::{AIProviderManager, AIContext, RewriteStyle, 
TextStream};
  |                                               ^^^^^^^^^^^^

warning: unused import: `Manager`
 --> src\commands\ai_writing.rs:7:20
  |
7 | use tauri::{State, Manager, Window};
  |                    ^^^^^^^

warning: unused import: `Serialize`
 --> src\commands\folder_commands.rs:6:26
  |
6 | use serde::{Deserialize, Serialize};
  |                          ^^^^^^^^^

warning: unused import: `Serialize`
 --> src\commands\series_commands.rs:6:26
  |
6 | use serde::{Deserialize, Serialize};
  |                          ^^^^^^^^^

warning: unused import: `Serialize`
 --> src\commands\document_link_commands.rs:6:26
  |
6 | use serde::{Deserialize, Serialize};
  |                          ^^^^^^^^^

warning: unused import: `Serialize`
 --> src\commands\settings_commands.rs:4:26
  |
4 | use serde::{Deserialize, Serialize};
  |                          ^^^^^^^^^

warning: unused import: `crate::commands::CommandResponse`
 --> src\commands\performance_commands.rs:7:5
  |
7 | use crate::commands::CommandResponse;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Deserialize` and `Serialize`
 --> src\commands\performance_commands.rs:9:13
  |
9 | use serde::{Deserialize, Serialize};
  |             ^^^^^^^^^^^  ^^^^^^^^^

warning: unused import: `tauri::State`
  --> src\commands\performance_commands.rs:10:5
   |
10 | use tauri::State;
   |     ^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
  --> src\commands\performance_commands.rs:11:5
   |
11 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `Deserialize`
 --> src\commands\project_preview_commands.rs:6:13
  |
6 | use serde::{Deserialize, Serialize};
  |             ^^^^^^^^^^^

warning: unused imports: `CharacterTemplateTrait` and 
`WorldBuildingTemplateProperty`
 --> src\commands\templates.rs:3:49
  |
3 |     character_template_ops::{CharacterTemplate, 
CharacterTemplateTrait},
  |                                                 ^^^^^^^^^^^^^^^^^^^^^^
4 |     worldbuilding_template_ops::{WorldBuildingTemplate, 
WorldBuildingTemplateProperty}
  |                                                         
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Deserialize` and `Serialize`
 --> src\commands\templates.rs:8:13
  |
8 | use serde::{Deserialize, Serialize};
  |             ^^^^^^^^^^^  ^^^^^^^^^

warning: unused import: `tauri::State`
  --> src\commands\templates.rs:10:5
   |
10 | use tauri::State;
   |     ^^^^^^^^^^^^

warning: unused import: `std::path::PathBuf`
 --> src\database\mod.rs:6:5
  |
6 | use std::path::PathBuf;
  |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `uuid::Uuid`
 --> src\database\operations\background_task_ops.rs:7:5
  |
7 | use uuid::Uuid;
  |     ^^^^^^^^^^

warning: unused import: `serde_json::json`
 --> src\database\operations\performance_metric_ops.rs:7:5
  |
7 | use serde_json::json;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `uuid::Uuid`
 --> src\database\operations\performance_metric_ops.rs:9:5
  |
9 | use uuid::Uuid;
  |     ^^^^^^^^^^

warning: unused import: `uuid::Uuid`
 --> src\database\operations\character_template_ops.rs:7:5
  |
7 | use uuid::Uuid;
  |     ^^^^^^^^^^

warning: unused import: `deleted_item_ops::*`
  --> src\database\operations\mod.rs:32:9
   |
32 | pub use deleted_item_ops::*;
   |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `project_ops::*`
  --> src\database\operations\mod.rs:34:9
   |
34 | pub use project_ops::*;
   |         ^^^^^^^^^^^^^^

warning: unused import: `document_ops::*`
  --> src\database\operations\mod.rs:35:9
   |
35 | pub use document_ops::*;
   |         ^^^^^^^^^^^^^^^

warning: unused import: `character_ops::*`
  --> src\database\operations\mod.rs:36:9
   |
36 | pub use character_ops::*;
   |         ^^^^^^^^^^^^^^^^

warning: unused import: `location_ops::*`
  --> src\database\operations\mod.rs:37:9
   |
37 | pub use location_ops::*;
   |         ^^^^^^^^^^^^^^^

warning: unused import: `background_task_ops::*`
  --> src\database\operations\mod.rs:38:9
   |
38 | pub use background_task_ops::*;
   |         ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `performance_metric_ops::*`
  --> src\database\operations\mod.rs:39:9
   |
39 | pub use performance_metric_ops::*;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `story_bible_ops::*`
  --> src\database\operations\mod.rs:40:9
   |
40 | pub use story_bible_ops::*;
   |         ^^^^^^^^^^^^^^^^^^

warning: unused import: `timeline_ops::*`
  --> src\database\operations\mod.rs:41:9
   |
41 | pub use timeline_ops::*;
   |         ^^^^^^^^^^^^^^^

warning: unused import: `plot_thread_ops::*`
  --> src\database\operations\mod.rs:42:9
   |
42 | pub use plot_thread_ops::*;
   |         ^^^^^^^^^^^^^^^^^^

warning: unused import: `character_trait_ops::*`
  --> src\database\operations\mod.rs:43:9
   |
43 | pub use character_trait_ops::*;
   |         ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `world_element_ops::*`
  --> src\database\operations\mod.rs:44:9
   |
44 | pub use world_element_ops::*;
   |         ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `outline_ops::*`
  --> src\database\operations\mod.rs:45:9
   |
45 | pub use outline_ops::*;
   |         ^^^^^^^^^^^^^^

warning: unused import: `outline_act_ops::*`
  --> src\database\operations\mod.rs:46:9
   |
46 | pub use outline_act_ops::*;
   |         ^^^^^^^^^^^^^^^^^^

warning: unused import: `scene_ops::*`
  --> src\database\operations\mod.rs:47:9
   |
47 | pub use scene_ops::*;
   |         ^^^^^^^^^^^^

warning: unused import: `series_consistency_ops::*`
  --> src\database\operations\mod.rs:48:9
   |
48 | pub use series_consistency_ops::*;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `style_example_ops::*`
  --> src\database\operations\mod.rs:49:9
   |
49 | pub use style_example_ops::*;
   |         ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ai_history_ops::*`
  --> src\database\operations\mod.rs:50:9
   |
50 | pub use ai_history_ops::*;
   |         ^^^^^^^^^^^^^^^^^

warning: unused import: `character_template_ops::*`
  --> src\database\operations\mod.rs:51:9
   |
51 | pub use character_template_ops::*;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `worldbuilding_template_ops::*`
  --> src\database\operations\mod.rs:52:9
   |
52 | pub use worldbuilding_template_ops::*;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Pool` and `Sqlite`
 --> src\database\backup.rs:2:12
  |
2 | use sqlx::{Pool, Sqlite};
  |            ^^^^  ^^^^^^

warning: unused import: `std::fmt`
 --> src\error.rs:5:5
  |
5 | use std::fmt;
  |     ^^^^^^^^

warning: unused import: `ai_card::*`
 --> src\models\mod.rs:5:9
  |
5 | pub use ai_card::*;
  |         ^^^^^^^^^^

warning: unused imports: `RewriteStyle` and `WritingFeature`
 --> src\ai\write_processor.rs:3:36
  |
3 | use super::{AIProvider, AIContext, WritingFeature, RewriteStyle};
  |                                    ^^^^^^^^^^^^^^  ^^^^^^^^^^^^

warning: unused import: `document_ops`
 --> src\ai\write_processor.rs:5:35
  |
5 | use crate::database::operations::{document_ops, DocumentOps};
  |                                   ^^^^^^^^^^^^

warning: unused import: `Context as AnyhowContext`
 --> src\ai\write_processor.rs:7:22
  |
7 | use anyhow::{Result, Context as AnyhowContext};
  |                      ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `tokio::sync::Mutex`
  --> src\ai\mod.rs:12:5
   |
12 | use tokio::sync::Mutex;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `sqlx::QueryBuilder`
  --> src\utils\performance_monitor.rs:12:5
   |
12 | use sqlx::QueryBuilder;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `serde_json::json`
  --> src\utils\performance_monitor.rs:15:5
   |
15 | use serde_json::json;
   |     ^^^^^^^^^^^^^^^^

warning: unused import: `performance_monitor::*`
 --> src\utils\mod.rs:7:9
  |
7 | pub use performance_monitor::*;
  |         ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `tauri::path::BaseDirectory`
  --> src\security\encryption.rs:16:5
   |
16 | use tauri::path::BaseDirectory;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Manager`
  --> src\security\encryption.rs:17:24
   |
17 | use tauri::{AppHandle, Manager};
   |                        ^^^^^^^

warning: unused import: `NaiveDateTime`
 --> src\security\audit.rs:9:29
  |
9 | use chrono::{DateTime, Utc, NaiveDateTime};
  |                             ^^^^^^^^^^^^^

warning: unused import: `tokio::sync::RwLock`
  --> src\security\audit.rs:12:5
   |
12 | use tokio::sync::RwLock;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `decrypt_string`
 --> src\security\privacy.rs:7:51
  |
7 | use crate::security::encryption::{encrypt_string, decrypt_string};
  |                                                   ^^^^^^^^^^^^^^

warning: unused variable: `tree`
   --> src\commands\documents.rs:181:17
    |
181 |         let mut tree: Vec<DocumentTree> = Vec::new();
    |                 ^^^^ help: if this is intentional, prefix it with 
an underscore: `_tree`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: variable does not need to be mutable
   --> src\commands\documents.rs:181:13
    |
181 |         let mut tree: Vec<DocumentTree> = Vec::new();
    |             ----^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: irrefutable `if let` pattern
   --> src\commands\locations.rs:330:16
    |
330 |             if let (current_type, other_type) = 
(&location.location_type, &other_location.location_type) {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this pattern will always match, so the `if let` is useless
    = help: consider replacing the `if let` with a `let`
    = note: `#[warn(irrefutable_let_patterns)]` on by default

error[E0308]: mismatched types
  --> src\commands\story_bible.rs:43:39
   |
43 |             global_character_pov_ids: 
request.global_character_pov_ids.unwrap_or_default(),
   |                                       
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, 
found `Vec<String>`
   |
   = note: expected struct `std::string::String`
              found struct `Vec<std::string::String>`

error[E0308]: mismatched types
  --> src\commands\story_bible.rs:98:26
   |
98 |             trait_value: request.trait_value,
   |                          ^^^^^^^^^^^^^^^^^^^ expected 
`Option<String>`, found `String`
   |
   = note: expected enum `std::option::Option<std::string::String>`
            found struct `std::string::String`
help: try wrapping the expression in `Some`
   |
98 |             trait_value: Some(request.trait_value),
   |                          +++++                   +

error[E0308]: mismatched types
   --> src\commands\story_bible.rs:191:25
    |
191 |             project_id: request.project_id.clone(),
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 
`Option<String>`, found `String`
    |
    = note: expected enum `std::option::Option<std::string::String>`
             found struct `std::string::String`
help: try wrapping the expression in `Some`
    |
191 |             project_id: Some(request.project_id.clone()),
    |                         +++++                          +

error[E0308]: mismatched types
   --> src\commands\story_bible.rs:196:25
    |
196 |             properties: request.properties.unwrap_or_default(),
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
expected `String`, found `HashMap<String, String>`
    |
    = note: expected struct `std::string::String`
               found struct `HashMap<std::string::String, 
std::string::String>`

error[E0308]: mismatched types
   --> src\commands\story_bible.rs:225:9
    |
225 |         WorldElementOps::get_by_id(&pool, &id).await
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 
`Result<Option<WorldElement>, ...>`, found `Result<WorldElement, 
StoryWeaverError>`
    |
    = note: expected enum 
`std::result::Result<std::option::Option<database::models::WorldElement>, 
_>`
               found enum 
`std::result::Result<database::models::WorldElement, _>`

error[E0061]: this function takes 2 arguments but 7 arguments were 
supplied
   --> src\commands\story_bible.rs:236:9
    |
236 | ...   WorldElementOps::update(&pool, &request.id, request.name, 
request.description, request.element_type, request.properties, 
request.is_visible).a...
    |       ^^^^^^^^^^^^^^^^^^^^^^^        -----------  ------------  
-------------------  --------------------  ------------------  
------------------ unexpected argument #7 of type 
`std::option::Option<bool>`
    |                                      |            |             |   
                 |                     |
    |                                      |            |             |   
                 |                     unexpected argument #6 of type 
`std::option::Option<HashMap<std::string::String, std::string::String>>`
    |                                      |            |             |   
                 unexpected argument #5 of type 
`std::option::Option<std::string::String>`
    |                                      |            |             
unexpected argument #4 of type `std::option::Option<std::string::String>`
    |                                      |            unexpected 
argument #3 of type `std::option::Option<std::string::String>`
    |                                      expected `WorldElement`, found 
`&String`
    |
note: associated function defined here
   --> src\database\operations\world_element_ops.rs:137:18
    |
137 |     pub async fn update(pool: &Pool<Sqlite>, world_element: 
WorldElement) -> Result<WorldElement> {
    |                  ^^^^^^                      
---------------------------
help: remove the extra arguments
    |
236 -         WorldElementOps::update(&pool, &request.id, request.name, 
request.description, request.element_type, request.properties, 
request.is_visible).await
236 +         WorldElementOps::update(&pool, /* 
database::models::WorldElement */).await
    |

error[E0308]: mismatched types
   --> src\commands\story_bible.rs:236:9
    |
236 | ...   WorldElementOps::update(&pool, &request.id, request.name, 
request.description, request.element_type, request.properties, 
request.is_visible).await
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^ expected `Result<(), StoryWeaverError>`, found 
`Result<WorldElement, StoryWeaverError>`
    |
    = note: expected enum `std::result::Result<(), _>`
               found enum 
`std::result::Result<database::models::WorldElement, _>`

error[E0308]: mismatched types
   --> src\commands\story_bible.rs:298:29
    |
298 |             chapter_number: request.chapter_number,
    |                             ^^^^^^^^^^^^^^^^^^^^^^ expected 
`Option<i32>`, found `i32`
    |
    = note: expected enum `std::option::Option<i32>`
               found type `i32`
help: try wrapping the expression in `Some`
    |
298 |             chapter_number: Some(request.chapter_number),
    |                             +++++                      +

error[E0308]: mismatched types
   --> src\commands\story_bible.rs:303:32
    |
303 |             character_pov_ids: 
request.character_pov_ids.unwrap_or_default(),
    |                                
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found 
`Vec<String>`
    |
    = note: expected struct `std::string::String`
               found struct `Vec<std::string::String>`

error[E0308]: mismatched types
   --> src\commands\story_bible.rs:330:9
    |
330 |         OutlineOps::get_by_id(&pool, &id).await
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 
`Result<Option<Outline>, ...>`, found `Result<Outline, StoryWeaverError>`
    |
    = note: expected enum 
`std::result::Result<std::option::Option<database::models::Outline>, _>`
               found enum `std::result::Result<database::models::Outline, 
_>`

error[E0061]: this function takes 2 arguments but 7 arguments were 
supplied
   --> src\commands\story_bible.rs:352:9
    |
352 |         OutlineOps::update(&pool, &request.id, request.title, 
request.summary, request.pov, request.tense, 
request.character_pov_ids).await
    |         ^^^^^^^^^^^^^^^^^^        -----------  -------------  
---------------  -----------  -------------  ------------------------- 
unexpected argument #7 of type 
`std::option::Option<Vec<std::string::String>>`
    |                                   |            |              |     
           |            |
    |                                   |            |              |     
           |            unexpected argument #6 of type 
`std::option::Option<std::string::String>`
    |                                   |            |              |     
           unexpected argument #5 of type 
`std::option::Option<std::string::String>`
    |                                   |            |              
unexpected argument #4 of type `std::option::Option<std::string::String>`
    |                                   |            unexpected argument 
#3 of type `std::option::Option<std::string::String>`
    |                                   expected `Outline`, found 
`&String`
    |
note: associated function defined here
   --> src\database\operations\outline_ops.rs:97:18
    |
97  |     pub async fn update(pool: &Pool<Sqlite>, outline: Outline) -> 
Result<Outline> {
    |                  ^^^^^^                      ----------------
help: remove the extra arguments
    |
352 -         OutlineOps::update(&pool, &request.id, request.title, 
request.summary, request.pov, request.tense, 
request.character_pov_ids).await
352 +         OutlineOps::update(&pool, /* database::models::Outline 
*/).await
    |

error[E0308]: mismatched types
   --> src\commands\story_bible.rs:352:9
    |
352 |         OutlineOps::update(&pool, &request.id, request.title, 
request.summary, request.pov, request.tense, 
request.character_pov_ids).await
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
expected `Result<(), StoryWeaverError>`, found `Result<Outline, 
StoryWeaverError>`
    |
    = note: expected enum `std::result::Result<(), _>`
               found enum `std::result::Result<database::models::Outline, 
_>`

error[E0308]: mismatched types
   --> src\commands\story_bible.rs:426:32
    |
426 |             character_pov_ids: 
request.character_pov_ids.unwrap_or_default(),
    |                                
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found 
`Vec<String>`
    |
    = note: expected struct `std::string::String`
               found struct `Vec<std::string::String>`

error[E0308]: mismatched types
   --> src\commands\story_bible.rs:457:9
    |
457 |         SceneOps::get_by_id(&pool, &id).await
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 
`Result<Option<Scene>, StoryWeaverError>`, found `Result<Scene, 
StoryWeaverError>`
    |
    = note: expected enum 
`std::result::Result<std::option::Option<database::models::Scene>, _>`
               found enum `std::result::Result<database::models::Scene, 
_>`

error[E0061]: this function takes 2 arguments but 10 arguments were 
supplied
   --> src\commands\story_bible.rs:468:9
    |
468 | ...   SceneOps::update(&pool, &request.id, request.title, 
request.summary, request.extra_instructions, request.pov, request.tense, 
reques...
    |       ^^^^^^^^^^^^^^^^        ----------- expected `Scene`, found 
`&String`
    |
note: associated function defined here
   --> src\database\operations\scene_ops.rs:106:18
    |
106 |     pub async fn update(pool: &Pool<Sqlite>, scene: Scene) -> 
Result<Scene> {
    |                  ^^^^^^                      ------------
help: remove the extra arguments
    |
468 -         SceneOps::update(&pool, &request.id, request.title, 
request.summary, request.extra_instructions, request.pov, request.tense, 
request.character_pov_ids, request.word_count_estimate, 
request.credit_estimate).await
468 +         SceneOps::update(&pool, /* database::models::Scene */).await
    |

error[E0308]: mismatched types
   --> src\commands\story_bible.rs:468:9
    |
468 | ...   SceneOps::update(&pool, &request.id, request.title, 
request.summary, request.extra_instructions, request.pov, request.tense, 
request.character_pov_ids, request.word_count_estimate, 
request.credit_estimate).await
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^ expected `Result<(), StoryWeaverError>`, found `Result<Scene, 
StoryWeaverError>`
    |
    = note: expected enum `std::result::Result<(), _>`
               found enum `std::result::Result<database::models::Scene, 
_>`

error[E0599]: no function or associated item named `validate` found for 
struct `operations::SceneOps` in the current scope
   --> src\commands\story_bible.rs:490:19
    |
490 |         SceneOps::validate(&pool, &id).await
    |                   ^^^^^^^^ function or associated item not found in 
`SceneOps`
    |
   ::: src\database\operations\mod.rs:74:1
    |
74  | pub struct SceneOps;
    | ------------------- function or associated item `validate` not 
found for this struct
    |
help: there is an associated function `get_validated` with a similar name
    |
490 -         SceneOps::validate(&pool, &id).await
490 +         SceneOps::get_validated(&pool, &id).await
    |

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:143:5
    |
143 |     generate(request, ai_manager.inner().clone()).await
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 
`CommandResponse<AIGenerationResponse>`, found 
`Result<AIGenerationResponse, ...>`
    |
    = note: expected struct `CommandResponse<AIGenerationResponse>`
                 found enum `std::result::Result<AIGenerationResponse, 
StoryWeaverError>`
help: call `Into::into` on this expression to convert 
`std::result::Result<AIGenerationResponse, StoryWeaverError>` into 
`CommandResponse<AIGenerationResponse>`
    |
143 |     generate(request, ai_manager.inner().clone()).await.into()
    |                                                        +++++++

error[E0308]: mismatched types
  --> src\commands\story_bible_ai.rs:93:31
   |
93 |             creativity_level: request.creativity,
   |                               ^^^^^^^^^^^^^^^^^^ expected 
`Option<u8>`, found `Option<f32>`
   |
   = note: expected enum `std::option::Option<u8>`
              found enum `std::option::Option<f32>`

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:94:32
    |
94  |             feature_type: Some("synopsis_generation".to_string()),
    |                           ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
expected `WritingFeature`, found `String`
    |                           |
    |                           arguments to this enum variant are 
incorrect
    |
help: the type constructed contains `std::string::String` due to the type 
of the argument passed
   --> src\commands\story_bible_ai.rs:94:27
    |
94  |             feature_type: Some("synopsis_generation".to_string()),
    |                           ^^^^^---------------------------------^
    |                                |
    |                                this argument influences the type of 
`Some`
note: tuple variant defined here
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\option.rs:597:5
    |
597 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^

error[E0599]: no method named `generate_text` found for struct 
`Arc<AIProviderManager>` in the current scope
   --> src\commands\story_bible_ai.rs:131:35
    |
131 |         let response = ai_manager.generate_text(&prompt, 
&context).await
    |                                   ^^^^^^^^^^^^^ method not found in 
`Arc<AIProviderManager>`
    |
    = help: items from traits can only be used if the trait is 
implemented and in scope
note: `AIProvider` defines an item `generate_text`, perhaps you need to 
implement it
   --> src\ai\mod.rs:126:1
    |
126 | pub trait AIProvider: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no variant named `AIGenerationError` found for enum 
`StoryWeaverError`
   --> src\commands\story_bible_ai.rs:132:44
    |
132 |             .map_err(|e| StoryWeaverError::AIGenerationError { 
message: e.to_string() })?;
    |                                            ^^^^^^^^^^^^^^^^^ 
variant not found in `StoryWeaverError`
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIGenerationError` not found here

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:156:31
    |
156 |             creativity_level: request.creativity,
    |                               ^^^^^^^^^^^^^^^^^^ expected 
`Option<u8>`, found `Option<f32>`
    |
    = note: expected enum `std::option::Option<u8>`
               found enum `std::option::Option<f32>`

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:157:32
    |
157 |             feature_type: 
Some("character_trait_generation".to_string()),
    |                           ---- 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `WritingFeature`, found 
`String`
    |                           |
    |                           arguments to this enum variant are 
incorrect
    |
help: the type constructed contains `std::string::String` due to the type 
of the argument passed
   --> src\commands\story_bible_ai.rs:157:27
    |
157 |             feature_type: 
Some("character_trait_generation".to_string()),
    |                           
^^^^^----------------------------------------^
    |                                |
    |                                this argument influences the type of 
`Some`
note: tuple variant defined here
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\option.rs:597:5
    |
597 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^

error[E0599]: no method named `generate_text` found for struct 
`Arc<AIProviderManager>` in the current scope
   --> src\commands\story_bible_ai.rs:187:35
    |
187 |         let response = ai_manager.generate_text(&prompt, 
&context).await
    |                                   ^^^^^^^^^^^^^ method not found in 
`Arc<AIProviderManager>`
    |
    = help: items from traits can only be used if the trait is 
implemented and in scope
note: `AIProvider` defines an item `generate_text`, perhaps you need to 
implement it
   --> src\ai\mod.rs:126:1
    |
126 | pub trait AIProvider: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no variant named `AIGenerationError` found for enum 
`StoryWeaverError`
   --> src\commands\story_bible_ai.rs:188:44
    |
188 |             .map_err(|e| StoryWeaverError::AIGenerationError { 
message: e.to_string() })?;
    |                                            ^^^^^^^^^^^^^^^^^ 
variant not found in `StoryWeaverError`
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIGenerationError` not found here

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:226:31
    |
226 |             creativity_level: request.creativity,
    |                               ^^^^^^^^^^^^^^^^^^ expected 
`Option<u8>`, found `Option<f32>`
    |
    = note: expected enum `std::option::Option<u8>`
               found enum `std::option::Option<f32>`

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:227:32
    |
227 |             feature_type: 
Some("world_element_generation".to_string()),
    |                           ---- 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `WritingFeature`, found 
`String`
    |                           |
    |                           arguments to this enum variant are 
incorrect
    |
help: the type constructed contains `std::string::String` due to the type 
of the argument passed
   --> src\commands\story_bible_ai.rs:227:27
    |
227 |             feature_type: 
Some("world_element_generation".to_string()),
    |                           
^^^^^--------------------------------------^
    |                                |
    |                                this argument influences the type of 
`Some`
note: tuple variant defined here
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\option.rs:597:5
    |
597 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^

error[E0599]: no method named `generate_text` found for struct 
`Arc<AIProviderManager>` in the current scope
   --> src\commands\story_bible_ai.rs:271:35
    |
271 |         let response = ai_manager.generate_text(&prompt, 
&context).await
    |                                   ^^^^^^^^^^^^^ method not found in 
`Arc<AIProviderManager>`
    |
    = help: items from traits can only be used if the trait is 
implemented and in scope
note: `AIProvider` defines an item `generate_text`, perhaps you need to 
implement it
   --> src\ai\mod.rs:126:1
    |
126 | pub trait AIProvider: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no variant named `AIGenerationError` found for enum 
`StoryWeaverError`
   --> src\commands\story_bible_ai.rs:272:44
    |
272 |             .map_err(|e| StoryWeaverError::AIGenerationError { 
message: e.to_string() })?;
    |                                            ^^^^^^^^^^^^^^^^^ 
variant not found in `StoryWeaverError`
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIGenerationError` not found here

error[E0599]: no function or associated item named `get_by_project` found 
for struct `operations::CharacterTraitOps` in the current scope
   --> src\commands\story_bible_ai.rs:299:45
    |
299 |         let characters = CharacterTraitOps::get_by_project(&pool, 
&project_id).await?;
    |                                             ^^^^^^^^^^^^^^ function 
or associated item not found in `CharacterTraitOps`
    |
   ::: src\database\operations\mod.rs:70:1
    |
70  | pub struct CharacterTraitOps;
    | ---------------------------- function or associated item 
`get_by_project` not found for this struct

error[E0599]: no method named `as_ref` found for struct 
`database::models::StoryBible` in the current scope
   --> src\commands\story_bible_ai.rs:303:36
    |
303 |         let synopsis = story_bible.as_ref()
    |                                    ^^^^^^ method not found in 
`StoryBible`
    |
   ::: src\database\models.rs:411:1
    |
411 | pub struct StoryBible {
    | --------------------- method `as_ref` not found for this struct
    |
    = help: items from traits can only be used if the trait is 
implemented and in scope
    = note: the following traits define an item `as_ref`, perhaps you 
need to implement one of them:
            candidate #1: `AsRef`
            candidate #2: `sqlx::Value`
help: some of the expressions' fields have a method of the same name
    |
303 |         let synopsis = story_bible.braindump.as_ref()
    |                                    ++++++++++
303 |         let synopsis = story_bible.genre.as_ref()
    |                                    ++++++
303 |         let synopsis = story_bible.global_pov.as_ref()
    |                                    +++++++++++
303 |         let synopsis = story_bible.global_tense.as_ref()
    |                                    +++++++++++++
      and 3 other candidates

error[E0599]: no method named `as_ref` found for struct 
`database::models::StoryBible` in the current scope
   --> src\commands\story_bible_ai.rs:305:37
    |
305 |             .or_else(|| story_bible.as_ref().and_then(|sb| 
sb.braindump.as_ref()))
    |                                     ^^^^^^ method not found in 
`StoryBible`
    |
   ::: src\database\models.rs:411:1
    |
411 | pub struct StoryBible {
    | --------------------- method `as_ref` not found for this struct
    |
    = help: items from traits can only be used if the trait is 
implemented and in scope
    = note: the following traits define an item `as_ref`, perhaps you 
need to implement one of them:
            candidate #1: `AsRef`
            candidate #2: `sqlx::Value`
help: some of the expressions' fields have a method of the same name
    |
305 |             .or_else(|| 
story_bible.braindump.as_ref().and_then(|sb| sb.braindump.as_ref()))
    |                                     ++++++++++
305 |             .or_else(|| story_bible.genre.as_ref().and_then(|sb| 
sb.braindump.as_ref()))
    |                                     ++++++
305 |             .or_else(|| 
story_bible.global_pov.as_ref().and_then(|sb| sb.braindump.as_ref()))
    |                                     +++++++++++
305 |             .or_else(|| 
story_bible.global_tense.as_ref().and_then(|sb| sb.braindump.as_ref()))
    |                                     +++++++++++++
      and 3 other candidates

error[E0599]: no method named `as_ref` found for struct 
`database::models::StoryBible` in the current scope
   --> src\commands\story_bible_ai.rs:309:33
    |
309 |         let genre = story_bible.as_ref()
    |                                 ^^^^^^ method not found in 
`StoryBible`
    |
   ::: src\database\models.rs:411:1
    |
411 | pub struct StoryBible {
    | --------------------- method `as_ref` not found for this struct
    |
    = help: items from traits can only be used if the trait is 
implemented and in scope
    = note: the following traits define an item `as_ref`, perhaps you 
need to implement one of them:
            candidate #1: `AsRef`
            candidate #2: `sqlx::Value`
help: some of the expressions' fields have a method of the same name
    |
309 |         let genre = story_bible.braindump.as_ref()
    |                                 ++++++++++
309 |         let genre = story_bible.genre.as_ref()
    |                                 ++++++
309 |         let genre = story_bible.global_pov.as_ref()
    |                                 +++++++++++
309 |         let genre = story_bible.global_tense.as_ref()
    |                                 +++++++++++++
      and 3 other candidates

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:336:31
    |
336 |             creativity_level: creativity,
    |                               ^^^^^^^^^^ expected `Option<u8>`, 
found `Option<f32>`
    |
    = note: expected enum `std::option::Option<u8>`
               found enum `std::option::Option<f32>`

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:337:32
    |
337 |             feature_type: Some("outline_generation".to_string()),
    |                           ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
expected `WritingFeature`, found `String`
    |                           |
    |                           arguments to this enum variant are 
incorrect
    |
help: the type constructed contains `std::string::String` due to the type 
of the argument passed
   --> src\commands\story_bible_ai.rs:337:27
    |
337 |             feature_type: Some("outline_generation".to_string()),
    |                           ^^^^^--------------------------------^
    |                                |
    |                                this argument influences the type of 
`Some`
note: tuple variant defined here
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\option.rs:597:5
    |
597 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^

error[E0599]: no method named `generate_text` found for struct 
`Arc<AIProviderManager>` in the current scope
   --> src\commands\story_bible_ai.rs:367:35
    |
367 |         let response = ai_manager.generate_text(&prompt, 
&context).await
    |                                   ^^^^^^^^^^^^^ method not found in 
`Arc<AIProviderManager>`
    |
    = help: items from traits can only be used if the trait is 
implemented and in scope
note: `AIProvider` defines an item `generate_text`, perhaps you need to 
implement it
   --> src\ai\mod.rs:126:1
    |
126 | pub trait AIProvider: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no variant named `AIGenerationError` found for enum 
`StoryWeaverError`
   --> src\commands\story_bible_ai.rs:368:44
    |
368 |             .map_err(|e| StoryWeaverError::AIGenerationError { 
message: e.to_string() })?;
    |                                            ^^^^^^^^^^^^^^^^^ 
variant not found in `StoryWeaverError`
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIGenerationError` not found here

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:403:31
    |
403 |             creativity_level: creativity,
    |                               ^^^^^^^^^^ expected `Option<u8>`, 
found `Option<f32>`
    |
    = note: expected enum `std::option::Option<u8>`
               found enum `std::option::Option<f32>`

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:404:32
    |
404 |             feature_type: Some("scene_generation".to_string()),
    |                           ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
expected `WritingFeature`, found `String`
    |                           |
    |                           arguments to this enum variant are 
incorrect
    |
help: the type constructed contains `std::string::String` due to the type 
of the argument passed
   --> src\commands\story_bible_ai.rs:404:27
    |
404 |             feature_type: Some("scene_generation".to_string()),
    |                           ^^^^^------------------------------^
    |                                |
    |                                this argument influences the type of 
`Some`
note: tuple variant defined here
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\option.rs:597:5
    |
597 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^

error[E0599]: no method named `generate_text` found for struct 
`Arc<AIProviderManager>` in the current scope
   --> src\commands\story_bible_ai.rs:423:35
    |
423 |         let response = ai_manager.generate_text(&prompt, 
&context).await
    |                                   ^^^^^^^^^^^^^ method not found in 
`Arc<AIProviderManager>`
    |
    = help: items from traits can only be used if the trait is 
implemented and in scope
note: `AIProvider` defines an item `generate_text`, perhaps you need to 
implement it
   --> src\ai\mod.rs:126:1
    |
126 | pub trait AIProvider: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no variant named `AIGenerationError` found for enum 
`StoryWeaverError`
   --> src\commands\story_bible_ai.rs:424:44
    |
424 |             .map_err(|e| StoryWeaverError::AIGenerationError { 
message: e.to_string() })?;
    |                                            ^^^^^^^^^^^^^^^^^ 
variant not found in `StoryWeaverError`
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIGenerationError` not found here

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:450:31
    |
450 |             creativity_level: request.creativity,
    |                               ^^^^^^^^^^^^^^^^^^ expected 
`Option<u8>`, found `Option<f32>`
    |
    = note: expected enum `std::option::Option<u8>`
               found enum `std::option::Option<f32>`

error[E0308]: mismatched types
   --> src\commands\story_bible_ai.rs:451:32
    |
451 |             feature_type: Some("style_analysis".to_string()),
    |                           ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
expected `WritingFeature`, found `String`
    |                           |
    |                           arguments to this enum variant are 
incorrect
    |
help: the type constructed contains `std::string::String` due to the type 
of the argument passed
   --> src\commands\story_bible_ai.rs:451:27
    |
451 |             feature_type: Some("style_analysis".to_string()),
    |                           ^^^^^----------------------------^
    |                                |
    |                                this argument influences the type of 
`Some`
note: tuple variant defined here
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\option.rs:597:5
    |
597 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^

error[E0599]: no method named `generate_text` found for struct 
`Arc<AIProviderManager>` in the current scope
   --> src\commands\story_bible_ai.rs:484:35
    |
484 |         let response = ai_manager.generate_text(&prompt, 
&context).await
    |                                   ^^^^^^^^^^^^^ method not found in 
`Arc<AIProviderManager>`
    |
    = help: items from traits can only be used if the trait is 
implemented and in scope
note: `AIProvider` defines an item `generate_text`, perhaps you need to 
implement it
   --> src\ai\mod.rs:126:1
    |
126 | pub trait AIProvider: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no variant named `AIGenerationError` found for enum 
`StoryWeaverError`
   --> src\commands\story_bible_ai.rs:485:44
    |
485 |             .map_err(|e| StoryWeaverError::AIGenerationError { 
message: e.to_string() })?;
    |                                            ^^^^^^^^^^^^^^^^^ 
variant not found in `StoryWeaverError`
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIGenerationError` not found here

error[E0061]: this function takes 3 arguments but 6 arguments were 
supplied
   --> src\commands\style_examples.rs:60:25
    |
60  |     let style_example = StyleExample::new(
    |                         ^^^^^^^^^^^^^^^^^
61  |         Uuid::new_v4().to_string(),
62  |         request.project_id,
    |         ------------------ unexpected argument #2 of type 
`std::string::String`
63  |         request.user_id,
64  |         request.example_text,
    |         -------------------- unexpected argument #4 of type 
`std::string::String`
65  |         None,
66  |         None,
    |         ---- unexpected argument #6 of type `std::option::Option<_>`
    |
note: associated function defined here
   --> src\database\models.rs:642:12
    |
642 |     pub fn new(project_id: String, user_id: Option<String>, 
example_text: String) -> Self {
    |            ^^^
help: remove the extra arguments
    |
61  ~         Uuid::new_v4().to_string(),
62  ~         request.user_id,
63  ~         None,
    |

error[E0308]: mismatched types
  --> src\commands\style_examples.rs:69:50
   |
69 |     let created = StyleExampleOps::create(&pool, 
&style_example).await?;
   |                   -----------------------        ^^^^^^^^^^^^^^ 
expected `StyleExample`, found `&StyleExample`
   |                   |
   |                   arguments to this function are incorrect
   |
note: associated function defined here
  --> src\database\operations\style_example_ops.rs:10:18
   |
10 |     pub async fn create(pool: &Pool<Sqlite>, style_example: 
StyleExample) -> Result<StyleExample> {
   |                  ^^^^^^                      
---------------------------
help: consider removing the borrow
   |
69 -     let created = StyleExampleOps::create(&pool, 
&style_example).await?;
69 +     let created = StyleExampleOps::create(&pool, 
style_example).await?;
   |

error[E0599]: no method named `ok_or_else` found for struct 
`database::models::StyleExample` in the current scope
   --> src\commands\style_examples.rs:103:10
    |
102 |       let style_example = StyleExampleOps::get_by_id(&pool, 
&id).await?
    |  _________________________-
103 | |         .ok_or_else(|| StoryWeaverError::NotFound { 
    | |         -^^^^^^^^^^ method not found in `StyleExample`
    | |_________|
    |
    |
   ::: src\database\models.rs:629:1
    |
629 |   pub struct StyleExample {
    |   ----------------------- method `ok_or_else` not found for this 
struct
    |
help: some of the expressions' fields have a method of the same name
    |
103 |         .analysis_result.ok_or_else(|| StoryWeaverError::NotFound { 
    |          ++++++++++++++++
103 |         .generated_style_prompt.ok_or_else(|| 
StoryWeaverError::NotFound { 
    |          +++++++++++++++++++++++
103 |         .user_id.ok_or_else(|| StoryWeaverError::NotFound { 
    |          ++++++++

error[E0599]: no variant named `NotFound` found for enum 
`StoryWeaverError`
   --> src\commands\style_examples.rs:103:42
    |
103 |         .ok_or_else(|| StoryWeaverError::NotFound { 
    |                                          ^^^^^^^^ variant not found 
in `StoryWeaverError`
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `NotFound` not found here

error[E0061]: this function takes 2 arguments but 5 arguments were 
supplied
   --> src\commands\style_examples.rs:118:19
    |
118 |     let updated = StyleExampleOps::update(
    |                   ^^^^^^^^^^^^^^^^^^^^^^^
119 |         &pool,
120 |         &request.id,
    |         ----------- expected `StyleExample`, found `&String`
121 |         request.example_text,
    |         -------------------- unexpected argument #3 of type 
`std::option::Option<std::string::String>`
122 |         request.analysis_result,
    |         ----------------------- unexpected argument #4 of type 
`std::option::Option<std::string::String>`
123 |         request.generated_style_prompt,
    |         ------------------------------ unexpected argument #5 of 
type `std::option::Option<std::string::String>`
    |
note: associated function defined here
   --> src\database\operations\style_example_ops.rs:74:18
    |
74  |     pub async fn update(pool: &Pool<Sqlite>, style_example: 
StyleExample) -> Result<StyleExample> {
    |                  ^^^^^^                      
---------------------------
help: remove the extra arguments
    |
120 -         &request.id,
120 +         /* database::models::StyleExample */,
    |

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:176:6
    |
176 | ) -> Result<WriteResult> {
    |      ^^^^^^ ----------- supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
176 | ) -> Result<WriteResult, E> {
    |                        +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:187:6
    |
187 | ) -> Result<WriteResult> {
    |      ^^^^^^ ----------- supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
187 | ) -> Result<WriteResult, E> {
    |                        +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:200:6
    |
200 | ) -> Result<StreamStartResponse> {
    |      ^^^^^^ ------------------- supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
200 | ) -> Result<StreamStartResponse, E> {
    |                                +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:258:6
    |
258 | ) -> Result<StreamStartResponse> {
    |      ^^^^^^ ------------------- supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
258 | ) -> Result<StreamStartResponse, E> {
    |                                +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:337:6
    |
337 | ) -> Result<String> {
    |      ^^^^^^ ------ supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
337 | ) -> Result<String, E> {
    |                   +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:362:6
    |
362 | ) -> Result<String> {
    |      ^^^^^^ ------ supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
362 | ) -> Result<String, E> {
    |                   +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:386:6
    |
386 | ) -> Result<String> {
    |      ^^^^^^ ------ supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
386 | ) -> Result<String, E> {
    |                   +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:410:6
    |
410 | ) -> Result<Vec<String>> {
    |      ^^^^^^ ----------- supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
410 | ) -> Result<Vec<String>, E> {
    |                        +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:432:6
    |
432 | ) -> Result<String> {
    |      ^^^^^^ ------ supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
432 | ) -> Result<String, E> {
    |                   +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:446:6
    |
446 | ) -> Result<String> {
    |      ^^^^^^ ------ supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
446 | ) -> Result<String, E> {
    |                   +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:460:6
    |
460 | ) -> Result<String> {
    |      ^^^^^^ ------ supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
460 | ) -> Result<String, E> {
    |                   +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:481:6
    |
481 | ) -> Result<WriteResult> {
    |      ^^^^^^ ----------- supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
481 | ) -> Result<WriteResult, E> {
    |                        +++

error[E0107]: enum takes 2 generic arguments but 1 generic argument was 
supplied
   --> src\commands\ai_writing.rs:496:6
    |
496 | ) -> Result<Vec<String>> {
    |      ^^^^^^ ----------- supplied 1 generic argument
    |      |
    |      expected 2 generic arguments
    |
note: enum defined here, with 2 generic parameters: `T`, `E`
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:548:10
    |
548 | pub enum Result<T, E> {
    |          ^^^^^^ -  -
help: add missing generic argument
    |
496 | ) -> Result<Vec<String>, E> {
    |                        +++

warning: unused variable: `settings`
  --> src\commands\ai_writing.rs:64:85
   |
64 | ...2, cursor_position: usize, settings: WriteSettings) -> 
crate::error::Result<TextStream> {
   |                               ^^^^^^^^ help: if this is intentional, 
prefix it with an underscore: `_settings`

warning: unused variable: `settings`
  --> src\commands\ai_writing.rs:81:82
   |
81 | ...d: i32, user_prompt: &str, settings: WriteSettings) -> 
crate::error::Result<TextStream> {
   |                               ^^^^^^^^ help: if this is intentional, 
prefix it with an underscore: `_settings`

warning: unused variable: `settings`
  --> src\commands\ai_writing.rs:98:78
   |
98 | ...2, cursor_position: usize, settings: WriteSettings) -> 
crate::error::Result<WriteResult> { // Changed return type to Result
   |                               ^^^^^^^^ help: if this is intentional, 
prefix it with an underscore: `_settings`

warning: unused variable: `settings`
   --> src\commands\ai_writing.rs:119:75
    |
119 | ...d: i32, user_prompt: &str, settings: WriteSettings) -> 
crate::error::Result<WriteResult> { // Changed return type to Result
    |                               ^^^^^^^^ help: if this is 
intentional, prefix it with an underscore: `_settings`

error[E0599]: no method named `emit` found for struct `tauri::Window` in 
the current scope
   --> src\commands\ai_writing.rs:227:44
    |
227 |                     if let Err(e) = window.emit("ai_stream_chunk", 
&chunk) {
    |                                            ^^^^
    |
   ::: C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:6
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |      ---- the method is available for `tauri::Window` here
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `emit_to` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:996:3
    |
996 | /   fn emit_to<I, S>(&self, target: I, event: &str, payload: S) -> 
Result<()>
997 | |   where
998 | |     I: Into<EventTarget>,
999 | |     S: Serialize + Clone,
    | |_________________________^
help: trait `Emitter` which provides `emit` is implemented but not in 
scope; perhaps you want to import it
    |
3   + use tauri::Emitter;
    |

error[E0599]: no method named `emit` found for struct `tauri::Window` in 
the current scope
   --> src\commands\ai_writing.rs:238:47
    |
238 |                 if let Err(emit_err) = 
window.emit("ai_stream_error", format!("Auto write stream failed: {}", 
e)) {
    |                                               ^^^^
    |
   ::: C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:6
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |      ---- the method is available for `tauri::Window` here
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `emit_to` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:996:3
    |
996 | /   fn emit_to<I, S>(&self, target: I, event: &str, payload: S) -> 
Result<()>
997 | |   where
998 | |     I: Into<EventTarget>,
999 | |     S: Serialize + Clone,
    | |_________________________^
help: trait `Emitter` which provides `emit` is implemented but not in 
scope; perhaps you want to import it
    |
3   + use tauri::Emitter;
    |

error[E0599]: no method named `emit` found for struct `tauri::Window` in 
the current scope
   --> src\commands\ai_writing.rs:285:44
    |
285 |                     if let Err(e) = window.emit("ai_stream_chunk", 
&chunk) {
    |                                            ^^^^
    |
   ::: C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:6
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |      ---- the method is available for `tauri::Window` here
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `emit_to` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:996:3
    |
996 | /   fn emit_to<I, S>(&self, target: I, event: &str, payload: S) -> 
Result<()>
997 | |   where
998 | |     I: Into<EventTarget>,
999 | |     S: Serialize + Clone,
    | |_________________________^
help: trait `Emitter` which provides `emit` is implemented but not in 
scope; perhaps you want to import it
    |
3   + use tauri::Emitter;
    |

error[E0599]: no method named `emit` found for struct `tauri::Window` in 
the current scope
   --> src\commands\ai_writing.rs:296:47
    |
296 |                 if let Err(emit_err) = 
window.emit("ai_stream_error", format!("Guided write stream failed: {}", 
e)) {
    |                                               ^^^^
    |
   ::: C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:6
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |      ---- the method is available for `tauri::Window` here
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `emit_to` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:996:3
    |
996 | /   fn emit_to<I, S>(&self, target: I, event: &str, payload: S) -> 
Result<()>
997 | |   where
998 | |     I: Into<EventTarget>,
999 | |     S: Serialize + Clone,
    | |_________________________^
help: trait `Emitter` which provides `emit` is implemented but not in 
scope; perhaps you want to import it
    |
3   + use tauri::Emitter;
    |

error[E0599]: no variant named `AIProviderError` found for enum 
`StoryWeaverError`
   --> src\commands\ai_writing.rs:353:53
    |
353 |         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
    |                                                     ^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIProviderError` not found here
    |
help: there is a variant with a similar name
    |
353 -         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
353 +         None => Err(crate::error::StoryWeaverError::AIProvider { 
message: "No AI provider available".to_string() }),
    |

error[E0599]: no variant named `AIProviderError` found for enum 
`StoryWeaverError`
   --> src\commands\ai_writing.rs:377:53
    |
377 |         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
    |                                                     ^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIProviderError` not found here
    |
help: there is a variant with a similar name
    |
377 -         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
377 +         None => Err(crate::error::StoryWeaverError::AIProvider { 
message: "No AI provider available".to_string() }),
    |

error[E0599]: no variant named `AIProviderError` found for enum 
`StoryWeaverError`
   --> src\commands\ai_writing.rs:401:53
    |
401 |         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
    |                                                     ^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIProviderError` not found here
    |
help: there is a variant with a similar name
    |
401 -         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
401 +         None => Err(crate::error::StoryWeaverError::AIProvider { 
message: "No AI provider available".to_string() }),
    |

error[E0599]: no variant named `AIProviderError` found for enum 
`StoryWeaverError`
   --> src\commands\ai_writing.rs:424:53
    |
424 |         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
    |                                                     ^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIProviderError` not found here
    |
help: there is a variant with a similar name
    |
424 -         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
424 +         None => Err(crate::error::StoryWeaverError::AIProvider { 
message: "No AI provider available".to_string() }),
    |

error[E0599]: no variant named `AIProviderError` found for enum 
`StoryWeaverError`
   --> src\commands\ai_writing.rs:437:53
    |
437 |         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
    |                                                     ^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIProviderError` not found here
    |
help: there is a variant with a similar name
    |
437 -         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
437 +         None => Err(crate::error::StoryWeaverError::AIProvider { 
message: "No AI provider available".to_string() }),
    |

error[E0599]: no variant named `AIProviderError` found for enum 
`StoryWeaverError`
   --> src\commands\ai_writing.rs:451:53
    |
451 |         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
    |                                                     ^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIProviderError` not found here
    |
help: there is a variant with a similar name
    |
451 -         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
451 +         None => Err(crate::error::StoryWeaverError::AIProvider { 
message: "No AI provider available".to_string() }),
    |

error[E0599]: no variant named `AIProviderError` found for enum 
`StoryWeaverError`
   --> src\commands\ai_writing.rs:470:53
    |
470 |         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
    |                                                     ^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIProviderError` not found here
    |
help: there is a variant with a similar name
    |
470 -         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
470 +         None => Err(crate::error::StoryWeaverError::AIProvider { 
message: "No AI provider available".to_string() }),
    |

error[E0599]: no variant named `AIProviderError` found for enum 
`StoryWeaverError`
   --> src\commands\ai_writing.rs:506:53
    |
506 |         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
    |                                                     ^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `AIProviderError` not found here
    |
help: there is a variant with a similar name
    |
506 -         None => Err(crate::error::StoryWeaverError::AIProviderError 
{ message: "No AI provider available".to_string() }),
506 +         None => Err(crate::error::StoryWeaverError::AIProvider { 
message: "No AI provider available".to_string() }),
    |

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:10:6
    |
10  | ) -> Result<AIResponseCard, String> {
    |      ^^^^^^               -------- help: remove the unnecessary 
generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:21:6
    |
21  | ) -> Result<AIResponseCard, String> {
    |      ^^^^^^               -------- help: remove the unnecessary 
generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:32:6
    |
32  | ) -> Result<Vec<AIResponseCard>, String> {
    |      ^^^^^^                    -------- help: remove the 
unnecessary generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:44:6
    |
44  | ) -> Result<AIResponseCard, String> {
    |      ^^^^^^               -------- help: remove the unnecessary 
generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:55:6
    |
55  | ) -> Result<(), String> {
    |      ^^^^^^   -------- help: remove the unnecessary generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:68:6
    |
68  | ) -> Result<Vec<AIResponseCard>, String> {
    |      ^^^^^^                    -------- help: remove the 
unnecessary generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:91:6
    |
91  | ) -> Result<Vec<AIResponseCard>, String> {
    |      ^^^^^^                    -------- help: remove the 
unnecessary generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:114:6
    |
114 | ) -> Result<Vec<AIResponseCard>, String> {
    |      ^^^^^^                    -------- help: remove the 
unnecessary generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:137:6
    |
137 | ) -> Result<Vec<AIResponseCard>, String> {
    |      ^^^^^^                    -------- help: remove the 
unnecessary generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:158:6
    |
158 | ) -> Result<AIResponseCard, String> {
    |      ^^^^^^               -------- help: remove the unnecessary 
generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:182:6
    |
182 | ) -> Result<AIResponseCard, String> {
    |      ^^^^^^               -------- help: remove the unnecessary 
generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0107]: type alias takes 1 generic argument but 2 generic arguments 
were supplied
   --> src\commands\ai_cards.rs:206:6
    |
206 | ) -> Result<AIResponseCard, String> {
    |      ^^^^^^               -------- help: remove the unnecessary 
generic argument
    |      |
    |      expected 1 generic argument
    |
note: type alias defined here, with 1 generic parameter: `T`
   --> src\error.rs:344:10
    |
344 | pub type Result<T> = std::result::Result<T, StoryWeaverError>;
    |          ^^^^^^ -

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
  --> src\commands\ai_cards.rs:11:53
   |
11 |     let pool = get_pool().map_err(|e| e.to_string())?;
   |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
   |                |          |
   |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
   |                this has type `Result<_, StoryWeaverError>`
   |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
  --> src\error.rs:11:1
   |
11 | pub enum StoryWeaverError {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
   = help: the following other types implement trait `From<T>`:
             `StoryWeaverError` implements `From<reqwest::Error>`
             `StoryWeaverError` implements `From<serde_json::Error>`
             `StoryWeaverError` implements `From<sqlx::Error>`
             `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
  --> src\commands\ai_cards.rs:13:5
   |
10 |   ) -> Result<AIResponseCard, String> {
   |        ------------------------------ expected 
`std::result::Result<AIResponseCard, StoryWeaverError>` because of return 
type
...
13 | /     AIResponseCard::create(&pool, request)
14 | |         .await
15 | |         .map_err(|e| e.to_string())
   | |___________________________________^ expected 
`Result<AIResponseCard, StoryWeaverError>`, found `Result<AIResponseCard, 
String>`
   |
   = note: expected enum `std::result::Result<_, StoryWeaverError>`
              found enum `std::result::Result<_, std::string::String>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
  --> src\commands\ai_cards.rs:22:53
   |
22 |     let pool = get_pool().map_err(|e| e.to_string())?;
   |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
   |                |          |
   |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
   |                this has type `Result<_, StoryWeaverError>`
   |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
  --> src\error.rs:11:1
   |
11 | pub enum StoryWeaverError {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
   = help: the following other types implement trait `From<T>`:
             `StoryWeaverError` implements `From<reqwest::Error>`
             `StoryWeaverError` implements `From<serde_json::Error>`
             `StoryWeaverError` implements `From<sqlx::Error>`
             `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
  --> src\commands\ai_cards.rs:24:5
   |
21 |   ) -> Result<AIResponseCard, String> {
   |        ------------------------------ expected 
`std::result::Result<AIResponseCard, StoryWeaverError>` because of return 
type
...
24 | /     AIResponseCard::get_by_id(&pool, &id)
25 | |         .await
26 | |         .map_err(|e| e.to_string())
   | |___________________________________^ expected 
`Result<AIResponseCard, StoryWeaverError>`, found `Result<AIResponseCard, 
String>`
   |
   = note: expected enum `std::result::Result<_, StoryWeaverError>`
              found enum `std::result::Result<_, std::string::String>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
  --> src\commands\ai_cards.rs:33:53
   |
33 |     let pool = get_pool().map_err(|e| e.to_string())?;
   |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
   |                |          |
   |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
   |                this has type `Result<_, StoryWeaverError>`
   |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
  --> src\error.rs:11:1
   |
11 | pub enum StoryWeaverError {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
   = help: the following other types implement trait `From<T>`:
             `StoryWeaverError` implements `From<reqwest::Error>`
             `StoryWeaverError` implements `From<serde_json::Error>`
             `StoryWeaverError` implements `From<sqlx::Error>`
             `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
  --> src\commands\ai_cards.rs:35:5
   |
32 |   ) -> Result<Vec<AIResponseCard>, String> {
   |        ----------------------------------- expected 
`std::result::Result<Vec<AIResponseCard>, StoryWeaverError>` because of 
return type
...
35 | /     AIResponseCard::get_filtered(&pool, filter)
36 | |         .await
37 | |         .map_err(|e| e.to_string())
   | |___________________________________^ expected 
`Result<Vec<AIResponseCard>, ...>`, found `Result<Vec<AIResponseCard>, 
String>`
   |
   = note: expected enum `std::result::Result<_, StoryWeaverError>`
              found enum `std::result::Result<_, std::string::String>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
  --> src\commands\ai_cards.rs:45:53
   |
45 |     let pool = get_pool().map_err(|e| e.to_string())?;
   |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
   |                |          |
   |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
   |                this has type `Result<_, StoryWeaverError>`
   |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
  --> src\error.rs:11:1
   |
11 | pub enum StoryWeaverError {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
   = help: the following other types implement trait `From<T>`:
             `StoryWeaverError` implements `From<reqwest::Error>`
             `StoryWeaverError` implements `From<serde_json::Error>`
             `StoryWeaverError` implements `From<sqlx::Error>`
             `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
  --> src\commands\ai_cards.rs:47:5
   |
44 |   ) -> Result<AIResponseCard, String> {
   |        ------------------------------ expected 
`std::result::Result<AIResponseCard, StoryWeaverError>` because of return 
type
...
47 | /     AIResponseCard::update(&pool, &id, request)
48 | |         .await
49 | |         .map_err(|e| e.to_string())
   | |___________________________________^ expected 
`Result<AIResponseCard, StoryWeaverError>`, found `Result<AIResponseCard, 
String>`
   |
   = note: expected enum `std::result::Result<_, StoryWeaverError>`
              found enum `std::result::Result<_, std::string::String>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
  --> src\commands\ai_cards.rs:56:53
   |
56 |     let pool = get_pool().map_err(|e| e.to_string())?;
   |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
   |                |          |
   |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
   |                this has type `Result<_, StoryWeaverError>`
   |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
  --> src\error.rs:11:1
   |
11 | pub enum StoryWeaverError {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
   = help: the following other types implement trait `From<T>`:
             `StoryWeaverError` implements `From<reqwest::Error>`
             `StoryWeaverError` implements `From<serde_json::Error>`
             `StoryWeaverError` implements `From<sqlx::Error>`
             `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
  --> src\commands\ai_cards.rs:58:5
   |
55 |   ) -> Result<(), String> {
   |        ------------------ expected `std::result::Result<(), 
StoryWeaverError>` because of return type
...
58 | /     AIResponseCard::delete(&pool, &id)
59 | |         .await
60 | |         .map_err(|e| e.to_string())
   | |___________________________________^ expected `Result<(), 
StoryWeaverError>`, found `Result<(), String>`
   |
   = note: expected enum `std::result::Result<_, StoryWeaverError>`
              found enum `std::result::Result<_, std::string::String>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
  --> src\commands\ai_cards.rs:69:53
   |
69 |     let pool = get_pool().map_err(|e| e.to_string())?;
   |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
   |                |          |
   |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
   |                this has type `Result<_, StoryWeaverError>`
   |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
  --> src\error.rs:11:1
   |
11 | pub enum StoryWeaverError {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
   = help: the following other types implement trait `From<T>`:
             `StoryWeaverError` implements `From<reqwest::Error>`
             `StoryWeaverError` implements `From<serde_json::Error>`
             `StoryWeaverError` implements `From<sqlx::Error>`
             `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
  --> src\commands\ai_cards.rs:81:5
   |
68 |   ) -> Result<Vec<AIResponseCard>, String> {
   |        ----------------------------------- expected 
`std::result::Result<Vec<AIResponseCard>, StoryWeaverError>` because of 
return type
...
81 | /     AIResponseCard::get_filtered(&pool, filter)
82 | |         .await
83 | |         .map_err(|e| e.to_string())
   | |___________________________________^ expected 
`Result<Vec<AIResponseCard>, ...>`, found `Result<Vec<AIResponseCard>, 
String>`
   |
   = note: expected enum `std::result::Result<_, StoryWeaverError>`
              found enum `std::result::Result<_, std::string::String>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
  --> src\commands\ai_cards.rs:92:53
   |
92 |     let pool = get_pool().map_err(|e| e.to_string())?;
   |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
   |                |          |
   |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
   |                this has type `Result<_, StoryWeaverError>`
   |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
  --> src\error.rs:11:1
   |
11 | pub enum StoryWeaverError {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
   = help: the following other types implement trait `From<T>`:
             `StoryWeaverError` implements `From<reqwest::Error>`
             `StoryWeaverError` implements `From<serde_json::Error>`
             `StoryWeaverError` implements `From<sqlx::Error>`
             `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
   --> src\commands\ai_cards.rs:104:5
    |
91  |   ) -> Result<Vec<AIResponseCard>, String> {
    |        ----------------------------------- expected 
`std::result::Result<Vec<AIResponseCard>, StoryWeaverError>` because of 
return type
...
104 | /     AIResponseCard::get_filtered(&pool, filter)
105 | |         .await
106 | |         .map_err(|e| e.to_string())
    | |___________________________________^ expected 
`Result<Vec<AIResponseCard>, ...>`, found `Result<Vec<AIResponseCard>, 
String>`
    |
    = note: expected enum `std::result::Result<_, StoryWeaverError>`
               found enum `std::result::Result<_, std::string::String>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
   --> src\commands\ai_cards.rs:115:53
    |
115 |     let pool = get_pool().map_err(|e| e.to_string())?;
    |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
    |                |          |
    |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
    |                this has type `Result<_, StoryWeaverError>`
    |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
   --> src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
    = help: the following other types implement trait `From<T>`:
              `StoryWeaverError` implements `From<reqwest::Error>`
              `StoryWeaverError` implements `From<serde_json::Error>`
              `StoryWeaverError` implements `From<sqlx::Error>`
              `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
   --> src\commands\ai_cards.rs:127:5
    |
114 |   ) -> Result<Vec<AIResponseCard>, String> {
    |        ----------------------------------- expected 
`std::result::Result<Vec<AIResponseCard>, StoryWeaverError>` because of 
return type
...
127 | /     AIResponseCard::get_filtered(&pool, filter)
128 | |         .await
129 | |         .map_err(|e| e.to_string())
    | |___________________________________^ expected 
`Result<Vec<AIResponseCard>, ...>`, found `Result<Vec<AIResponseCard>, 
String>`
    |
    = note: expected enum `std::result::Result<_, StoryWeaverError>`
               found enum `std::result::Result<_, std::string::String>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
   --> src\commands\ai_cards.rs:138:53
    |
138 |     let pool = get_pool().map_err(|e| e.to_string())?;
    |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
    |                |          |
    |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
    |                this has type `Result<_, StoryWeaverError>`
    |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
   --> src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
    = help: the following other types implement trait `From<T>`:
              `StoryWeaverError` implements `From<reqwest::Error>`
              `StoryWeaverError` implements `From<serde_json::Error>`
              `StoryWeaverError` implements `From<sqlx::Error>`
              `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
   --> src\commands\ai_cards.rs:150:5
    |
137 |   ) -> Result<Vec<AIResponseCard>, String> {
    |        ----------------------------------- expected 
`std::result::Result<Vec<AIResponseCard>, StoryWeaverError>` because of 
return type
...
150 | /     AIResponseCard::get_filtered(&pool, filter)
151 | |         .await
152 | |         .map_err(|e| e.to_string())
    | |___________________________________^ expected 
`Result<Vec<AIResponseCard>, ...>`, found `Result<Vec<AIResponseCard>, 
String>`
    |
    = note: expected enum `std::result::Result<_, StoryWeaverError>`
               found enum `std::result::Result<_, std::string::String>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
   --> src\commands\ai_cards.rs:159:53
    |
159 |     let pool = get_pool().map_err(|e| e.to_string())?;
    |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
    |                |          |
    |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
    |                this has type `Result<_, StoryWeaverError>`
    |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
   --> src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
    = help: the following other types implement trait `From<T>`:
              `StoryWeaverError` implements `From<reqwest::Error>`
              `StoryWeaverError` implements `From<serde_json::Error>`
              `StoryWeaverError` implements `From<sqlx::Error>`
              `StoryWeaverError` implements `From<std::io::Error>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
   --> src\commands\ai_cards.rs:164:36
    |
162 |       let current_card = AIResponseCard::get_by_id(&pool, &id)
    |  ________________________-
163 | |         .await
    | |______________- this has type `Result<_, StoryWeaverError>`
164 |           .map_err(|e| e.to_string())?;
    |            --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
    |            |
    |            this can't be annotated with `?` because it has type 
`Result<_, std::string::String>`
    |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
   --> src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
    = help: the following other types implement trait `From<T>`:
              `StoryWeaverError` implements `From<reqwest::Error>`
              `StoryWeaverError` implements `From<serde_json::Error>`
              `StoryWeaverError` implements `From<sqlx::Error>`
              `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
   --> src\commands\ai_cards.rs:174:5
    |
158 |   ) -> Result<AIResponseCard, String> {
    |        ------------------------------ expected 
`std::result::Result<AIResponseCard, StoryWeaverError>` because of return 
type
...
174 | /     AIResponseCard::update(&pool, &id, request)
175 | |         .await
176 | |         .map_err(|e| e.to_string())
    | |___________________________________^ expected 
`Result<AIResponseCard, StoryWeaverError>`, found `Result<AIResponseCard, 
String>`
    |
    = note: expected enum `std::result::Result<_, StoryWeaverError>`
               found enum `std::result::Result<_, std::string::String>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
   --> src\commands\ai_cards.rs:183:53
    |
183 |     let pool = get_pool().map_err(|e| e.to_string())?;
    |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
    |                |          |
    |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
    |                this has type `Result<_, StoryWeaverError>`
    |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
   --> src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
    = help: the following other types implement trait `From<T>`:
              `StoryWeaverError` implements `From<reqwest::Error>`
              `StoryWeaverError` implements `From<serde_json::Error>`
              `StoryWeaverError` implements `From<sqlx::Error>`
              `StoryWeaverError` implements `From<std::io::Error>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
   --> src\commands\ai_cards.rs:188:36
    |
186 |       let current_card = AIResponseCard::get_by_id(&pool, &id)
    |  ________________________-
187 | |         .await
    | |______________- this has type `Result<_, StoryWeaverError>`
188 |           .map_err(|e| e.to_string())?;
    |            --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
    |            |
    |            this can't be annotated with `?` because it has type 
`Result<_, std::string::String>`
    |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
   --> src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
    = help: the following other types implement trait `From<T>`:
              `StoryWeaverError` implements `From<reqwest::Error>`
              `StoryWeaverError` implements `From<serde_json::Error>`
              `StoryWeaverError` implements `From<sqlx::Error>`
              `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
   --> src\commands\ai_cards.rs:198:5
    |
182 |   ) -> Result<AIResponseCard, String> {
    |        ------------------------------ expected 
`std::result::Result<AIResponseCard, StoryWeaverError>` because of return 
type
...
198 | /     AIResponseCard::update(&pool, &id, request)
199 | |         .await
200 | |         .map_err(|e| e.to_string())
    | |___________________________________^ expected 
`Result<AIResponseCard, StoryWeaverError>`, found `Result<AIResponseCard, 
String>`
    |
    = note: expected enum `std::result::Result<_, StoryWeaverError>`
               found enum `std::result::Result<_, std::string::String>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
   --> src\commands\ai_cards.rs:207:53
    |
207 |     let pool = get_pool().map_err(|e| e.to_string())?;
    |                ---------- --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
    |                |          |
    |                |          this can't be annotated with `?` because 
it has type `Result<_, std::string::String>`
    |                this has type `Result<_, StoryWeaverError>`
    |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
   --> src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
    = help: the following other types implement trait `From<T>`:
              `StoryWeaverError` implements `From<reqwest::Error>`
              `StoryWeaverError` implements `From<serde_json::Error>`
              `StoryWeaverError` implements `From<sqlx::Error>`
              `StoryWeaverError` implements `From<std::io::Error>`

error[E0277]: `?` couldn't convert the error to `StoryWeaverError`
   --> src\commands\ai_cards.rs:212:36
    |
210 |       let current_card = AIResponseCard::get_by_id(&pool, &id)
    |  ________________________-
211 | |         .await
    | |______________- this has type `Result<_, StoryWeaverError>`
212 |           .map_err(|e| e.to_string())?;
    |            --------------------------^ the trait 
`From<std::string::String>` is not implemented for `StoryWeaverError`
    |            |
    |            this can't be annotated with `?` because it has type 
`Result<_, std::string::String>`
    |
note: `StoryWeaverError` needs to implement `From<std::string::String>`
   --> src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a 
conversion on the error value using the `From` trait
    = help: the following other types implement trait `From<T>`:
              `StoryWeaverError` implements `From<reqwest::Error>`
              `StoryWeaverError` implements `From<serde_json::Error>`
              `StoryWeaverError` implements `From<sqlx::Error>`
              `StoryWeaverError` implements `From<std::io::Error>`

error[E0308]: mismatched types
   --> src\commands\ai_cards.rs:222:5
    |
206 |   ) -> Result<AIResponseCard, String> {
    |        ------------------------------ expected 
`std::result::Result<AIResponseCard, StoryWeaverError>` because of return 
type
...
222 | /     AIResponseCard::update(&pool, &id, request)
223 | |         .await
224 | |         .map_err(|e| e.to_string())
    | |___________________________________^ expected 
`Result<AIResponseCard, StoryWeaverError>`, found `Result<AIResponseCard, 
String>`
    |
    = note: expected enum `std::result::Result<_, StoryWeaverError>`
               found enum `std::result::Result<_, std::string::String>`

error[E0308]: mismatched types
  --> src\commands\series_commands.rs:92:34
   |
92 |             series.description = description;
   |             ------------------   ^^^^^^^^^^^ expected 
`Option<String>`, found `String`
   |             |
   |             expected due to the type of this binding
   |
   = note: expected enum `std::option::Option<std::string::String>`
            found struct `std::string::String`
help: try wrapping the expression in `Some`
   |
92 |             series.description = Some(description);
   |                                  +++++           +

error[E0308]: mismatched types
   --> src\commands\settings_commands.rs:107:13
    |
106 |         UserPreferenceOps::set_preference(
    |         --------------------------------- arguments to this 
function are incorrect
107 |             pool, 
    |             ^^^^ expected `&Pool<Sqlite>`, found `Arc<Pool<Sqlite>>`
    |
    = note: expected reference `&Pool<_>`
                  found struct `Arc<Pool<_>>`
note: associated function defined here
   --> src\database\operations\app_settings_ops.rs:130:18
    |
130 |     pub async fn set_preference(
    |                  ^^^^^^^^^^^^^^
131 |         pool: &Pool<Sqlite>, 
    |         -------------------
help: consider borrowing here
    |
107 |             &pool, 
    |             +

error[E0599]: no method named `emit_to` found for reference `&AppHandle` 
in the current scope
   --> src\commands\sync_commands.rs:47:14
    |
46  | /         app_handle
47  | |             .emit_to(window.label(), &request.event_type, 
request.payload)
    | |_____________-^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `emit` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:3
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^
help: trait `Emitter` which provides `emit_to` is implemented but not in 
scope; perhaps you want to import it
    |
1   + use tauri::Emitter;
    |

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:63:20
    |
63  |         .fetch_one(&pool)
    |          --------- ^^^^^ the trait `Executor<'_>` is not 
implemented for `&Arc<Pool<Sqlite>>`
    |          |
    |          required by a bound introduced by this call
    |
note: required by a bound in `QueryScalar::<'q, DB, O, A>::fetch_one`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query_scalar.rs:160:17
    |
157 |     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> 
Result<O, Error>
    |                  --------- required by a bound in this associated 
function
...
160 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `QueryScalar::<'q, DB, O, A>::fetch_one`
help: consider dereferencing here
    |
63  |         .fetch_one(&*pool)
    |                     +

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:59:30
    |
59  |           let document_count = sqlx::query_scalar::<_, i64>(
    |  ______________________________^
60  | |             "SELECT COUNT(*) FROM documents WHERE project_id = ?"
61  | |         )
62  | |         .bind(&project_id)
63  | |         .fetch_one(&pool)
    | |_________________________^ the trait `Executor<'_>` is not 
implemented for `&Arc<Pool<Sqlite>>`
    |
    = help: the following other types implement trait `Executor<'c>`:
              `&'c mut AnyConnection` implements `Executor<'c>`
              `&'c mut SqliteConnection` implements `Executor<'c>`
              `&Pool<DB>` implements `Executor<'p>`
note: required by a bound in `QueryScalar::<'q, DB, O, A>::fetch_one`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query_scalar.rs:160:17
    |
157 |     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> 
Result<O, Error>
    |                  --------- required by a bound in this associated 
function
...
160 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `QueryScalar::<'q, DB, O, A>::fetch_one`

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:64:10
    |
64  |         .await
    |          ^^^^^ the trait `Executor<'_>` is not implemented for 
`&Arc<Pool<Sqlite>>`
    |
    = help: the following other types implement trait `Executor<'c>`:
              `&'c mut AnyConnection` implements `Executor<'c>`
              `&'c mut SqliteConnection` implements `Executor<'c>`
              `&Pool<DB>` implements `Executor<'p>`
note: required by a bound in `QueryScalar::<'q, DB, O, A>::fetch_one`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query_scalar.rs:160:17
    |
157 |     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> 
Result<O, Error>
    |                  --------- required by a bound in this associated 
function
...
160 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `QueryScalar::<'q, DB, O, A>::fetch_one`

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:72:20
    |
72  |         .fetch_one(&pool)
    |          --------- ^^^^^ the trait `Executor<'_>` is not 
implemented for `&Arc<Pool<Sqlite>>`
    |          |
    |          required by a bound introduced by this call
    |
note: required by a bound in `QueryScalar::<'q, DB, O, A>::fetch_one`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query_scalar.rs:160:17
    |
157 |     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> 
Result<O, Error>
    |                  --------- required by a bound in this associated 
function
...
160 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `QueryScalar::<'q, DB, O, A>::fetch_one`
help: consider dereferencing here
    |
72  |         .fetch_one(&*pool)
    |                     +

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:68:31
    |
68  |           let character_count = sqlx::query_scalar::<_, i64>(
    |  _______________________________^
69  | |             "SELECT COUNT(*) FROM characters WHERE project_id = ?"
70  | |         )
71  | |         .bind(&project_id)
72  | |         .fetch_one(&pool)
    | |_________________________^ the trait `Executor<'_>` is not 
implemented for `&Arc<Pool<Sqlite>>`
    |
    = help: the following other types implement trait `Executor<'c>`:
              `&'c mut AnyConnection` implements `Executor<'c>`
              `&'c mut SqliteConnection` implements `Executor<'c>`
              `&Pool<DB>` implements `Executor<'p>`
note: required by a bound in `QueryScalar::<'q, DB, O, A>::fetch_one`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query_scalar.rs:160:17
    |
157 |     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> 
Result<O, Error>
    |                  --------- required by a bound in this associated 
function
...
160 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `QueryScalar::<'q, DB, O, A>::fetch_one`

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:73:10
    |
73  |         .await
    |          ^^^^^ the trait `Executor<'_>` is not implemented for 
`&Arc<Pool<Sqlite>>`
    |
    = help: the following other types implement trait `Executor<'c>`:
              `&'c mut AnyConnection` implements `Executor<'c>`
              `&'c mut SqliteConnection` implements `Executor<'c>`
              `&Pool<DB>` implements `Executor<'p>`
note: required by a bound in `QueryScalar::<'q, DB, O, A>::fetch_one`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query_scalar.rs:160:17
    |
157 |     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> 
Result<O, Error>
    |                  --------- required by a bound in this associated 
function
...
160 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `QueryScalar::<'q, DB, O, A>::fetch_one`

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:81:20
    |
81  |         .fetch_one(&pool)
    |          --------- ^^^^^ the trait `Executor<'_>` is not 
implemented for `&Arc<Pool<Sqlite>>`
    |          |
    |          required by a bound introduced by this call
    |
note: required by a bound in `QueryScalar::<'q, DB, O, A>::fetch_one`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query_scalar.rs:160:17
    |
157 |     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> 
Result<O, Error>
    |                  --------- required by a bound in this associated 
function
...
160 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `QueryScalar::<'q, DB, O, A>::fetch_one`
help: consider dereferencing here
    |
81  |         .fetch_one(&*pool)
    |                     +

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:77:30
    |
77  |           let location_count = sqlx::query_scalar::<_, i64>(
    |  ______________________________^
78  | |             "SELECT COUNT(*) FROM locations WHERE project_id = ?"
79  | |         )
80  | |         .bind(&project_id)
81  | |         .fetch_one(&pool)
    | |_________________________^ the trait `Executor<'_>` is not 
implemented for `&Arc<Pool<Sqlite>>`
    |
    = help: the following other types implement trait `Executor<'c>`:
              `&'c mut AnyConnection` implements `Executor<'c>`
              `&'c mut SqliteConnection` implements `Executor<'c>`
              `&Pool<DB>` implements `Executor<'p>`
note: required by a bound in `QueryScalar::<'q, DB, O, A>::fetch_one`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query_scalar.rs:160:17
    |
157 |     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> 
Result<O, Error>
    |                  --------- required by a bound in this associated 
function
...
160 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `QueryScalar::<'q, DB, O, A>::fetch_one`

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:82:10
    |
82  |         .await
    |          ^^^^^ the trait `Executor<'_>` is not implemented for 
`&Arc<Pool<Sqlite>>`
    |
    = help: the following other types implement trait `Executor<'c>`:
              `&'c mut AnyConnection` implements `Executor<'c>`
              `&'c mut SqliteConnection` implements `Executor<'c>`
              `&Pool<DB>` implements `Executor<'p>`
note: required by a bound in `QueryScalar::<'q, DB, O, A>::fetch_one`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query_scalar.rs:160:17
    |
157 |     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> 
Result<O, Error>
    |                  --------- required by a bound in this associated 
function
...
160 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `QueryScalar::<'q, DB, O, A>::fetch_one`

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:96:20
    |
96  |         .fetch_all(&pool)
    |          --------- ^^^^^ the trait `Executor<'_>` is not 
implemented for `&Arc<Pool<Sqlite>>`
    |          |
    |          required by a bound introduced by this call
    |
note: required by a bound in `sqlx::query::Map::<'q, DB, F, A>::fetch_all`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query.rs:400:17
    |
397 |     pub async fn fetch_all<'e, 'c: 'e, E>(self, executor: E) -> 
Result<Vec<O>, Error>
    |                  --------- required by a bound in this associated 
function
...
400 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `Map::<'q, DB, F, A>::fetch_all`
help: consider dereferencing here
    |
96  |         .fetch_all(&*pool)
    |                     +

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:86:54
    |
86  |           let recent_documents: Vec<DocumentSummary> = sqlx::query!(
    |  ______________________________________________________^
87  | |             r#"
88  | |             SELECT id, title, document_type as "document_type: 
String", word_count, updated_at
89  | |             FROM documents 
...   |
96  | |         .fetch_all(&pool)
    | |_________________________^ the trait `Executor<'_>` is not 
implemented for `&Arc<Pool<Sqlite>>`
    |
    = help: the following other types implement trait `Executor<'c>`:
              `&'c mut AnyConnection` implements `Executor<'c>`
              `&'c mut SqliteConnection` implements `Executor<'c>`
              `&Pool<DB>` implements `Executor<'p>`
note: required by a bound in `sqlx::query::Map::<'q, DB, F, A>::fetch_all`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query.rs:400:17
    |
397 |     pub async fn fetch_all<'e, 'c: 'e, E>(self, executor: E) -> 
Result<Vec<O>, Error>
    |                  --------- required by a bound in this associated 
function
...
400 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `Map::<'q, DB, F, A>::fetch_all`

error[E0277]: the trait bound `&Arc<Pool<Sqlite>>: Executor<'_>` is not 
satisfied
   --> src\commands\project_preview_commands.rs:97:10
    |
97  |         .await
    |          ^^^^^ the trait `Executor<'_>` is not implemented for 
`&Arc<Pool<Sqlite>>`
    |
    = help: the following other types implement trait `Executor<'c>`:
              `&'c mut AnyConnection` implements `Executor<'c>`
              `&'c mut SqliteConnection` implements `Executor<'c>`
              `&Pool<DB>` implements `Executor<'p>`
note: required by a bound in `sqlx::query::Map::<'q, DB, F, A>::fetch_all`
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\sqlx-core-0.7.4\src\query.rs:400:17
    |
397 |     pub async fn fetch_all<'e, 'c: 'e, E>(self, executor: E) -> 
Result<Vec<O>, Error>
    |                  --------- required by a bound in this associated 
function
...
400 |         E: 'e + Executor<'c, Database = DB>,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound 
in `Map::<'q, DB, F, A>::fetch_all`

error[E0308]: mismatched types
   --> src\commands\project_preview_commands.rs:101:17
    |
101 |             id: row.id,
    |                 ^^^^^^- help: try using a conversion method: 
`.to_string()`
    |                 |
    |                 expected `String`, found `i64`

error[E0308]: mismatched types
   --> src\commands\project_preview_commands.rs:104:25
    |
104 |             word_count: row.word_count,
    |                         ^^^^^^^^^^^^^^ expected `i32`, found 
`Option<i64>`
    |
    = note: expected type `i32`
               found enum `std::option::Option<i64>`

error[E0308]: mismatched types
   --> src\commands\project_preview_commands.rs:105:25
    |
105 |             updated_at: row.updated_at,
    |                         ^^^^^^^^^^^^^^ expected `DateTime<Utc>`, 
found `Option<NaiveDateTime>`
    |
    = note: expected struct `DateTime<Utc>`
                 found enum `std::option::Option<NaiveDateTime>`

error[E0277]: `std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>` 
is not a future
  --> src\commands\series_consistency_commands.rs:13:27
   |
13 |     let pool = get_pool().await.map_err(|e| e.to_string())?;
   |                ---------- ^^^^^ 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>` is not a future
   |                |
   |                this call returns 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>`
   |
   = help: the trait `futures_util::Future` is not implemented for 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>`
   = note: std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError> must 
be a future or must implement `IntoFuture` to be awaited
   = note: required for `std::result::Result<Arc<Pool<Sqlite>>, 
StoryWeaverError>` to implement `std::future::IntoFuture`
help: remove the `.await`
   |
13 -     let pool = get_pool().await.map_err(|e| e.to_string())?;
13 +     let pool = get_pool().map_err(|e| e.to_string())?;
   |
help: alternatively, consider making `fn get_pool` asynchronous
  --> src\database\mod.rs:62:4
   |
62 | pub async fn get_pool() -> Result<Arc<DbPool>> {
   |     +++++

error[E0277]: `std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>` 
is not a future
  --> src\commands\series_consistency_commands.rs:26:27
   |
26 |     let pool = get_pool().await.map_err(|e| e.to_string())?;
   |                ---------- ^^^^^ 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>` is not a future
   |                |
   |                this call returns 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>`
   |
   = help: the trait `futures_util::Future` is not implemented for 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>`
   = note: std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError> must 
be a future or must implement `IntoFuture` to be awaited
   = note: required for `std::result::Result<Arc<Pool<Sqlite>>, 
StoryWeaverError>` to implement `std::future::IntoFuture`
help: remove the `.await`
   |
26 -     let pool = get_pool().await.map_err(|e| e.to_string())?;
26 +     let pool = get_pool().map_err(|e| e.to_string())?;
   |
help: alternatively, consider making `fn get_pool` asynchronous
  --> src\database\mod.rs:62:4
   |
62 | pub async fn get_pool() -> Result<Arc<DbPool>> {
   |     +++++

error[E0277]: `std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>` 
is not a future
  --> src\commands\series_consistency_commands.rs:40:27
   |
40 |     let pool = get_pool().await.map_err(|e| e.to_string())?;
   |                ---------- ^^^^^ 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>` is not a future
   |                |
   |                this call returns 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>`
   |
   = help: the trait `futures_util::Future` is not implemented for 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>`
   = note: std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError> must 
be a future or must implement `IntoFuture` to be awaited
   = note: required for `std::result::Result<Arc<Pool<Sqlite>>, 
StoryWeaverError>` to implement `std::future::IntoFuture`
help: remove the `.await`
   |
40 -     let pool = get_pool().await.map_err(|e| e.to_string())?;
40 +     let pool = get_pool().map_err(|e| e.to_string())?;
   |
help: alternatively, consider making `fn get_pool` asynchronous
  --> src\database\mod.rs:62:4
   |
62 | pub async fn get_pool() -> Result<Arc<DbPool>> {
   |     +++++

error[E0277]: `std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>` 
is not a future
  --> src\commands\series_consistency_commands.rs:61:27
   |
61 |     let pool = get_pool().await.map_err(|e| e.to_string())?;
   |                ---------- ^^^^^ 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>` is not a future
   |                |
   |                this call returns 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>`
   |
   = help: the trait `futures_util::Future` is not implemented for 
`std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError>`
   = note: std::result::Result<Arc<Pool<Sqlite>>, StoryWeaverError> must 
be a future or must implement `IntoFuture` to be awaited
   = note: required for `std::result::Result<Arc<Pool<Sqlite>>, 
StoryWeaverError>` to implement `std::future::IntoFuture`
help: remove the `.await`
   |
61 -     let pool = get_pool().await.map_err(|e| e.to_string())?;
61 +     let pool = get_pool().map_err(|e| e.to_string())?;
   |
help: alternatively, consider making `fn get_pool` asynchronous
  --> src\database\mod.rs:62:4
   |
62 | pub async fn get_pool() -> Result<Arc<DbPool>> {
   |     +++++

error[E0061]: this function takes 4 arguments but 6 arguments were 
supplied
   --> src\commands\templates.rs:40:24
    |
40  |     let character_id = 
CharacterTemplateOps::apply_template_to_character(
    |                        
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
44  |         &name,
    |         ----- unexpected argument #4 of type `&std::string::String`
45  |         description,
    |         ----------- unexpected argument #5 of type 
`std::option::Option<std::string::String>`
    |
note: associated function defined here
   --> src\database\operations\character_template_ops.rs:277:18
    |
277 |     pub async fn apply_template_to_character(
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: remove the extra arguments
    |
43  -         &project_id,
44  -         &name,
43  +         &project_id,
    |

error[E0308]: mismatched types
   --> src\commands\templates.rs:48:8
    |
48  |     Ok(character_id)
    |     -- ^^^^^^^^^^^^ expected `String`, found `Vec<CharacterTrait>`
    |     |
    |     arguments to this enum variant are incorrect
    |
    = note: expected struct `std::string::String`
               found struct `Vec<database::models::CharacterTrait>`
help: the type constructed contains 
`Vec<database::models::CharacterTrait>` due to the type of the argument 
passed
   --> src\commands\templates.rs:48:5
    |
48  |     Ok(character_id)
    |     ^^^------------^
    |        |
    |        this argument influences the type of `Ok`
note: tuple variant defined here
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:552:5
    |
552 |     Ok(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^

warning: unused variable: `database_url`
  --> src\database\mod.rs:33:9
   |
33 |     let database_url = format!("sqlite:{}", db_path.display());
   |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an 
underscore: `_database_url`

error[E0061]: this enum variant takes 1 argument but 0 arguments were 
supplied
   --> src\database\migrations.rs:79:5
    |
79  |     Ok()
    |     ^^-- argument #1 of type `()` is missing
    |
note: tuple variant defined here
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:552:5
    |
552 |     Ok(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^
help: provide the argument
    |
79  |     Ok(())
    |        ++

error[E0061]: this enum variant takes 1 argument but 0 arguments were 
supplied
   --> src\database\migrations.rs:119:5
    |
119 |     Ok()
    |     ^^-- argument #1 of type `()` is missing
    |
note: tuple variant defined here
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\result.rs:552:5
    |
552 |     Ok(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^
help: provide the argument
    |
119 |     Ok(())
    |        ++

warning: unused variable: `tree`
   --> src\database\operations\folder_ops.rs:194:17
    |
194 |         let mut tree: Vec<FolderTreeNode> = Vec::new();
    |                 ^^^^ help: if this is intentional, prefix it with 
an underscore: `_tree`

warning: variable does not need to be mutable
   --> src\database\operations\folder_ops.rs:194:13
    |
194 |         let mut tree: Vec<FolderTreeNode> = Vec::new();
    |             ----^^^^
    |             |
    |             help: remove this `mut`

error[E0277]: the trait bound `std::string::String: From<i64>` is not 
satisfied
   --> src\database\operations\series_ops.rs:141:22
    |
141 |           let series = sqlx::query_as!(
    |  ______________________^
142 | |             SeriesWithCount,
143 | |             r#"
144 | |             SELECT 
...   |
159 | |             "#
160 | |         )
    | |_________^ the trait `From<i64>` is not implemented for 
`std::string::String`
    |
    = help: the following other types implement trait `From<T>`:
              `std::string::String` implements `From<&mut str>`
              `std::string::String` implements 
`From<&std::string::String>`
              `std::string::String` implements `From<&str>`
              `std::string::String` implements `From<AssetKey>`
              `std::string::String` implements `From<Box<str>>`
              `std::string::String` implements `From<Cow<'_, str>>`
              `std::string::String` implements `From<Uuid>`
              `std::string::String` implements `From<char>`
            and 8 others
    = note: required for `i64` to implement `Into<std::string::String>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0277]: the trait bound `std::option::Option<std::string::String>: 
From<std::option::Option<i64>>` is not satisfied
   --> src\database\operations\series_ops.rs:141:22
    |
141 |           let series = sqlx::query_as!(
    |  ______________________^
142 | |             SeriesWithCount,
143 | |             r#"
144 | |             SELECT 
...   |
159 | |             "#
160 | |         )
    | |_________^ the trait `From<std::option::Option<i64>>` is not 
implemented for `std::option::Option<std::string::String>`
    |
    = help: the following other types implement trait `From<T>`:
              `std::option::Option<&T>` implements 
`From<&std::option::Option<T>>`
              `std::option::Option<&mut T>` implements `From<&mut 
std::option::Option<T>>`
              
`std::option::Option<&tracing_core::metadata::Metadata<'_>>` implements 
`From<&tracing_core::span::Current>`
              `std::option::Option<&tracing_core::span::Id>` implements 
`From<&tracing::span::EnteredSpan>`
              `std::option::Option<&tracing_core::span::Id>` implements 
`From<&tracing::span::Span>`
              `std::option::Option<&tracing_core::span::Id>` implements 
`From<&tracing_core::span::Current>`
              `std::option::Option<T>` implements `From<T>`
              `std::option::Option<T>` implements 
`From<subtle::CtOption<T>>`
            and 19 others
    = note: required for `std::option::Option<i64>` to implement 
`Into<std::option::Option<std::string::String>>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0277]: the trait bound `DateTime<Utc>: 
From<std::option::Option<NaiveDateTime>>` is not satisfied
   --> src\database\operations\series_ops.rs:141:22
    |
141 |           let series = sqlx::query_as!(
    |  ______________________^
142 | |             SeriesWithCount,
143 | |             r#"
144 | |             SELECT 
...   |
159 | |             "#
160 | |         )
    | |_________^ the trait `From<std::option::Option<NaiveDateTime>>` is 
not implemented for `DateTime<Utc>`
    |
    = help: the following other types implement trait `From<T>`:
              `DateTime<Utc>` implements `From<DateTime<FixedOffset>>`
              `DateTime<Utc>` implements `From<DateTime<chrono::Local>>`
              `DateTime<Utc>` implements `From<SystemTime>`
    = note: required for `std::option::Option<NaiveDateTime>` to 
implement `Into<DateTime<Utc>>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0277]: the trait bound `std::string::String: From<i64>` is not 
satisfied
   --> src\database\operations\document_link_ops.rs:140:24
    |
140 |           let previous = sqlx::query_as!(
    |  ________________________^
141 | |             LinkedDocument,
142 | |             r#"
143 | |             SELECT 
...   |
157 | |             document_id
158 | |         )
    | |_________^ the trait `From<i64>` is not implemented for 
`std::string::String`
    |
    = help: the following other types implement trait `From<T>`:
              `std::string::String` implements `From<&mut str>`
              `std::string::String` implements 
`From<&std::string::String>`
              `std::string::String` implements `From<&str>`
              `std::string::String` implements `From<AssetKey>`
              `std::string::String` implements `From<Box<str>>`
              `std::string::String` implements `From<Cow<'_, str>>`
              `std::string::String` implements `From<Uuid>`
              `std::string::String` implements `From<char>`
            and 8 others
    = note: required for `i64` to implement `Into<std::string::String>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0277]: the trait bound `i32: From<std::option::Option<i64>>` is 
not satisfied
   --> src\database\operations\document_link_ops.rs:140:24
    |
140 |           let previous = sqlx::query_as!(
    |  ________________________^
141 | |             LinkedDocument,
142 | |             r#"
143 | |             SELECT 
...   |
157 | |             document_id
158 | |         )
    | |_________^ the trait `From<std::option::Option<i64>>` is not 
implemented for `i32`
    |
    = help: the following other types implement trait `From<T>`:
              `i32` implements `From<bool>`
              `i32` implements `From<deranged::RangedI32<MIN, MAX>>`
              `i32` implements `From<dpi::LogicalUnit<P>>`
              `i32` implements `From<dpi::PhysicalUnit<P>>`
              `i32` implements `From<i16>`
              `i32` implements `From<i8>`
              `i32` implements 
`From<miniz_oxide::deflate::core::CompressionStrategy>`
              `i32` implements `From<notify_rust::timeout::Timeout>`
            and 10 others
    = note: required for `std::option::Option<i64>` to implement 
`Into<i32>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0277]: the trait bound `std::string::String: From<i64>` is not 
satisfied
   --> src\database\operations\document_link_ops.rs:164:20
    |
164 |           let next = sqlx::query_as!(
    |  ____________________^
165 | |             LinkedDocument,
166 | |             r#"
167 | |             SELECT 
...   |
181 | |             document_id
182 | |         )
    | |_________^ the trait `From<i64>` is not implemented for 
`std::string::String`
    |
    = help: the following other types implement trait `From<T>`:
              `std::string::String` implements `From<&mut str>`
              `std::string::String` implements 
`From<&std::string::String>`
              `std::string::String` implements `From<&str>`
              `std::string::String` implements `From<AssetKey>`
              `std::string::String` implements `From<Box<str>>`
              `std::string::String` implements `From<Cow<'_, str>>`
              `std::string::String` implements `From<Uuid>`
              `std::string::String` implements `From<char>`
            and 8 others
    = note: required for `i64` to implement `Into<std::string::String>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0277]: the trait bound `i32: From<std::option::Option<i64>>` is 
not satisfied
   --> src\database\operations\document_link_ops.rs:164:20
    |
164 |           let next = sqlx::query_as!(
    |  ____________________^
165 | |             LinkedDocument,
166 | |             r#"
167 | |             SELECT 
...   |
181 | |             document_id
182 | |         )
    | |_________^ the trait `From<std::option::Option<i64>>` is not 
implemented for `i32`
    |
    = help: the following other types implement trait `From<T>`:
              `i32` implements `From<bool>`
              `i32` implements `From<deranged::RangedI32<MIN, MAX>>`
              `i32` implements `From<dpi::LogicalUnit<P>>`
              `i32` implements `From<dpi::PhysicalUnit<P>>`
              `i32` implements `From<i16>`
              `i32` implements `From<i8>`
              `i32` implements 
`From<miniz_oxide::deflate::core::CompressionStrategy>`
              `i32` implements `From<notify_rust::timeout::Timeout>`
            and 10 others
    = note: required for `std::option::Option<i64>` to implement 
`Into<i32>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0308]: mismatched types
   --> src\database\operations\document_version_ops.rs:112:22
    |
112 |             content: document.content,
    |                      ^^^^^^^^^^^^^^^^ expected `String`, found 
`Option<String>`
    |
    = note: expected struct `std::string::String`
                 found enum `std::option::Option<std::string::String>`
help: consider using `Option::expect` to unwrap the 
`std::option::Option<std::string::String>` value, panicking if the value 
is an `Option::None`
    |
112 |             content: document.content.expect("REASON"),
    |                                      +++++++++++++++++

error[E0308]: mismatched types
   --> src\database\operations\document_version_ops.rs:113:25
    |
113 |             word_count: document.word_count,
    |                         ^^^^^^^^^^^^^^^^^^^ expected `i32`, found 
`Option<i64>`
    |
    = note: expected type `i32`
               found enum `std::option::Option<i64>`

error[E0308]: mismatched types
   --> src\database\operations\document_version_ops.rs:152:39
    |
152 |         let version = Self::get_by_id(&mut *tx, version_id).await?
    |                       --------------- ^^^^^^^^ expected 
`&Pool<Sqlite>`, found `&mut SqliteConnection`
    |                       |
    |                       arguments to this function are incorrect
    |
    = note:      expected reference `&Pool<Sqlite>`
            found mutable reference `&mut SqliteConnection`
note: associated function defined here
   --> src\database\operations\document_version_ops.rs:39:18
    |
39  |     pub async fn get_by_id(pool: &Pool<Sqlite>, id: &str) -> 
Result<Option<DocumentVersion>> {
    |                  ^^^^^^^^^ -------------------

error[E0277]: the trait bound `std::string::String: 
From<std::option::Option<std::string::String>>` is not satisfied
   --> src\database\operations\document_version_ops.rs:180:24
    |
180 |           let versions = sqlx::query_as!(
    |  ________________________^
181 | |             VersionHistoryItem,
182 | |             r#"
183 | |             SELECT 
...   |
201 | |             document_id
202 | |         )
    | |_________^ the trait 
`From<std::option::Option<std::string::String>>` is not implemented for 
`std::string::String`
    |
    = help: the following other types implement trait `From<T>`:
              `std::string::String` implements `From<&mut str>`
              `std::string::String` implements 
`From<&std::string::String>`
              `std::string::String` implements `From<&str>`
              `std::string::String` implements `From<AssetKey>`
              `std::string::String` implements `From<Box<str>>`
              `std::string::String` implements `From<Cow<'_, str>>`
              `std::string::String` implements `From<Uuid>`
              `std::string::String` implements `From<char>`
            and 8 others
    = note: required for `std::option::Option<std::string::String>` to 
implement `Into<std::string::String>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0277]: the trait bound `i32: From<i64>` is not satisfied
   --> src\database\operations\document_version_ops.rs:180:24
    |
180 |           let versions = sqlx::query_as!(
    |  ________________________^
181 | |             VersionHistoryItem,
182 | |             r#"
183 | |             SELECT 
...   |
201 | |             document_id
202 | |         )
    | |_________^ the trait `From<i64>` is not implemented for `i32`
    |
    = help: the following other types implement trait `From<T>`:
              `i32` implements `From<bool>`
              `i32` implements `From<deranged::RangedI32<MIN, MAX>>`
              `i32` implements `From<dpi::LogicalUnit<P>>`
              `i32` implements `From<dpi::PhysicalUnit<P>>`
              `i32` implements `From<i16>`
              `i32` implements `From<i8>`
              `i32` implements 
`From<miniz_oxide::deflate::core::CompressionStrategy>`
              `i32` implements `From<notify_rust::timeout::Timeout>`
            and 10 others
    = note: required for `i64` to implement `Into<i32>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0277]: the trait bound `DateTime<Utc>: From<NaiveDateTime>` is not 
satisfied
   --> src\database\operations\document_version_ops.rs:180:24
    |
180 |           let versions = sqlx::query_as!(
    |  ________________________^
181 | |             VersionHistoryItem,
182 | |             r#"
183 | |             SELECT 
...   |
201 | |             document_id
202 | |         )
    | |_________^ the trait `From<NaiveDateTime>` is not implemented for 
`DateTime<Utc>`
    |
    = help: the following other types implement trait `From<T>`:
              `DateTime<Utc>` implements `From<DateTime<FixedOffset>>`
              `DateTime<Utc>` implements `From<DateTime<chrono::Local>>`
              `DateTime<Utc>` implements `From<SystemTime>`
    = note: required for `NaiveDateTime` to implement 
`Into<DateTime<Utc>>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0277]: the trait bound `Record: Serialize` is not satisfied
    --> src\database\operations\deleted_item_ops.rs:150:50
     |
150  |         let project_data = serde_json::to_string(&project)
     |                            --------------------- ^^^^^^^^ 
unsatisfied trait bound
     |                            |
     |                            required by a bound introduced by this 
call
     |
     = help: the trait `commands::_::_serde::Serialize` is not 
implemented for `deleted_item_ops::<impl 
DeletedItemOps>::trash_project::{closure#0}::Record`
     = note: for local types consider adding 
`#[derive(serde::Serialize)]` to your `deleted_item_ops::<impl 
DeletedItemOps>::trash_project::{closure#0}::Record` type
     = note: for types from other crates check whether the crate offers a 
`serde` feature flag
     = help: the following other types implement trait 
`commands::_::_serde::Serialize`:
               &'a T
               &'a mut T
               ()
               (T,)
               (T0, T1)
               (T0, T1, T2)
               (T0, T1, T2, T3)
               (T0, T1, T2, T3, T4)
             and 558 others
note: required by a bound in `serde_json::to_string`
    --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557
f\serde_json-1.0.142\src\ser.rs:2247:17
     |
2245 | pub fn to_string<T>(value: &T) -> Result<String>
     |        --------- required by a bound in this function
2246 | where
2247 |     T: ?Sized + Serialize,
     |                 ^^^^^^^^^ required by this bound in `to_string`
     = note: the full name for the type has been written to 'C:\Users\jjgo
r\JSG-StoryWeaver\src-tauri\target\debug\deps\storyweaver_lib-05e1de4bae48
f710.long-type-12900289629671421947.txt'
     = note: consider using `--verbose` to print the full type name to 
the console

error[E0599]: no variant named `SerializationError` found for enum 
`StoryWeaverError`
   --> src\database\operations\deleted_item_ops.rs:151:44
    |
151 |             .map_err(|e| StoryWeaverError::SerializationError { 
message: e.to_string() })?;
    |                                            ^^^^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `SerializationError` not found 
here
    |
help: there is a variant with a similar name
    |
151 -             .map_err(|e| StoryWeaverError::SerializationError { 
message: e.to_string() })?;
151 +             .map_err(|e| StoryWeaverError::ValidationError { 
message: e.to_string() })?;
    |

error[E0277]: the trait bound `Record: Serialize` is not satisfied
    --> src\database\operations\deleted_item_ops.rs:222:51
     |
222  |         let document_data = serde_json::to_string(&document)
     |                             --------------------- ^^^^^^^^^ 
unsatisfied trait bound
     |                             |
     |                             required by a bound introduced by this 
call
     |
     = help: the trait `commands::_::_serde::Serialize` is not 
implemented for `deleted_item_ops::<impl 
DeletedItemOps>::trash_document::{closure#0}::Record`
     = note: for local types consider adding 
`#[derive(serde::Serialize)]` to your `deleted_item_ops::<impl 
DeletedItemOps>::trash_document::{closure#0}::Record` type
     = note: for types from other crates check whether the crate offers a 
`serde` feature flag
     = help: the following other types implement trait 
`commands::_::_serde::Serialize`:
               &'a T
               &'a mut T
               ()
               (T,)
               (T0, T1)
               (T0, T1, T2)
               (T0, T1, T2, T3)
               (T0, T1, T2, T3, T4)
             and 558 others
note: required by a bound in `serde_json::to_string`
    --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557
f\serde_json-1.0.142\src\ser.rs:2247:17
     |
2245 | pub fn to_string<T>(value: &T) -> Result<String>
     |        --------- required by a bound in this function
2246 | where
2247 |     T: ?Sized + Serialize,
     |                 ^^^^^^^^^ required by this bound in `to_string`
     = note: the full name for the type has been written to 'C:\Users\jjgo
r\JSG-StoryWeaver\src-tauri\target\debug\deps\storyweaver_lib-05e1de4bae48
f710.long-type-1915864201489912194.txt'
     = note: consider using `--verbose` to print the full type name to 
the console

error[E0599]: no variant named `SerializationError` found for enum 
`StoryWeaverError`
   --> src\database\operations\deleted_item_ops.rs:223:44
    |
223 |             .map_err(|e| StoryWeaverError::SerializationError { 
message: e.to_string() })?;
    |                                            ^^^^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `SerializationError` not found 
here
    |
help: there is a variant with a similar name
    |
223 -             .map_err(|e| StoryWeaverError::SerializationError { 
message: e.to_string() })?;
223 +             .map_err(|e| StoryWeaverError::ValidationError { 
message: e.to_string() })?;
    |

error[E0308]: mismatched types
   --> src\database\operations\deleted_item_ops.rs:231:29
    |
231 |             parent_id: Some(document.project_id),
    |                        ---- ^^^^^^^^^^^^^^^^^^^- help: try using a 
conversion method: `.to_string()`
    |                        |    |
    |                        |    expected `String`, found `i64`
    |                        arguments to this enum variant are incorrect
    |
help: the type constructed contains `i64` due to the type of the argument 
passed
   --> src\database\operations\deleted_item_ops.rs:231:24
    |
231 |             parent_id: Some(document.project_id),
    |                        ^^^^^-------------------^
    |                             |
    |                             this argument influences the type of 
`Some`
note: tuple variant defined here
   --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib
/rustlib/src/rust\library\core\src\option.rs:597:5
    |
597 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^

error[E0308]: mismatched types
   --> src\database\operations\deleted_item_ops.rs:280:44
    |
280 |         let deleted_item = Self::get_by_id(&mut *tx, 
deleted_item_id).await?
    |                            --------------- ^^^^^^^^ expected 
`&Pool<Sqlite>`, found `&mut SqliteConnection`
    |                            |
    |                            arguments to this function are incorrect
    |
    = note:      expected reference `&Pool<Sqlite>`
            found mutable reference `&mut SqliteConnection`
note: associated function defined here
   --> src\database\operations\deleted_item_ops.rs:39:18
    |
39  |     pub async fn get_by_id(pool: &Pool<Sqlite>, id: &str) -> 
Result<Option<DeletedItem>> {
    |                  ^^^^^^^^^ -------------------

error[E0599]: no variant named `DeserializationError` found for enum 
`StoryWeaverError`
   --> src\database\operations\deleted_item_ops.rs:288:52
    |
288 |                     .map_err(|e| 
StoryWeaverError::DeserializationError { message: e.to_string() })?;
    |                                                    
^^^^^^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `DeserializationError` not found 
here
    |
help: there is a variant with a similar name
    |
288 -                     .map_err(|e| 
StoryWeaverError::DeserializationError { message: e.to_string() })?;
288 +                     .map_err(|e| StoryWeaverError::Deserialization 
{ message: e.to_string() })?;
    |

error[E0599]: no variant named `DeserializationError` found for enum 
`StoryWeaverError`
   --> src\database\operations\deleted_item_ops.rs:319:52
    |
319 |                     .map_err(|e| 
StoryWeaverError::DeserializationError { message: e.to_string() })?;
    |                                                    
^^^^^^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `DeserializationError` not found 
here
    |
help: there is a variant with a similar name
    |
319 -                     .map_err(|e| 
StoryWeaverError::DeserializationError { message: e.to_string() })?;
319 +                     .map_err(|e| StoryWeaverError::Deserialization 
{ message: e.to_string() })?;
    |

error[E0599]: no variant named `DeserializationError` found for enum 
`StoryWeaverError`
   --> src\database\operations\deleted_item_ops.rs:350:52
    |
350 |                     .map_err(|e| 
StoryWeaverError::DeserializationError { message: e.to_string() })?;
    |                                                    
^^^^^^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `DeserializationError` not found 
here
    |
help: there is a variant with a similar name
    |
350 -                     .map_err(|e| 
StoryWeaverError::DeserializationError { message: e.to_string() })?;
350 +                     .map_err(|e| StoryWeaverError::Deserialization 
{ message: e.to_string() })?;
    |

error[E0599]: no variant named `DeserializationError` found for enum 
`StoryWeaverError`
   --> src\database\operations\deleted_item_ops.rs:373:52
    |
373 |                     .map_err(|e| 
StoryWeaverError::DeserializationError { message: e.to_string() })?;
    |                                                    
^^^^^^^^^^^^^^^^^^^^
    |
   ::: src\error.rs:11:1
    |
11  | pub enum StoryWeaverError {
    | ------------------------- variant `DeserializationError` not found 
here
    |
help: there is a variant with a similar name
    |
373 -                     .map_err(|e| 
StoryWeaverError::DeserializationError { message: e.to_string() })?;
373 +                     .map_err(|e| StoryWeaverError::Deserialization 
{ message: e.to_string() })?;
    |

error[E0559]: variant `StoryWeaverError::UnsupportedOperation` has no 
field named `message`
   --> src\database\operations\deleted_item_ops.rs:395:21
    |
395 |                     message: format!("Restore not implemented for 
item type: {:?}", deleted_item.item_type) 
    |                     ^^^^^^^ 
`StoryWeaverError::UnsupportedOperation` does not have this field
    |
    = note: available fields are: `operation`

error[E0308]: mismatched types
   --> src\database\operations\background_task_ops.rs:82:30
    |
82  |         Self::record_to_task(record)
    |         -------------------- ^^^^^^ expected `SqliteRow`, found 
`Record`
    |         |
    |         arguments to this function are incorrect
    |
note: associated function defined here
   --> src\database\operations\background_task_ops.rs:205:8
    |
205 |     fn record_to_task(record: sqlx::sqlite::SqliteRow) -> 
Result<Task> {
    |        ^^^^^^^^^^^^^^ -------------------------------

error[E0308]: mismatched types
   --> src\database\operations\background_task_ops.rs:98:45
    |
98  |             tasks.push(Self::record_to_task(record)?);
    |                        -------------------- ^^^^^^ expected 
`SqliteRow`, found `Record`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> src\database\operations\background_task_ops.rs:205:8
    |
205 |     fn record_to_task(record: sqlx::sqlite::SqliteRow) -> 
Result<Task> {
    |        ^^^^^^^^^^^^^^ -------------------------------

error[E0308]: mismatched types
   --> src\database\operations\background_task_ops.rs:126:45
    |
126 |             tasks.push(Self::record_to_task(record)?);
    |                        -------------------- ^^^^^^ expected 
`SqliteRow`, found `Record`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> src\database\operations\background_task_ops.rs:205:8
    |
205 |     fn record_to_task(record: sqlx::sqlite::SqliteRow) -> 
Result<Task> {
    |        ^^^^^^^^^^^^^^ -------------------------------

error[E0308]: mismatched types
   --> src\database\operations\background_task_ops.rs:146:45
    |
146 |             tasks.push(Self::record_to_task(record)?);
    |                        -------------------- ^^^^^^ expected 
`SqliteRow`, found `Record`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> src\database\operations\background_task_ops.rs:205:8
    |
205 |     fn record_to_task(record: sqlx::sqlite::SqliteRow) -> 
Result<Task> {
    |        ^^^^^^^^^^^^^^ -------------------------------

error[E0308]: mismatched types
   --> src\database\operations\background_task_ops.rs:166:45
    |
166 |             tasks.push(Self::record_to_task(record)?);
    |                        -------------------- ^^^^^^ expected 
`SqliteRow`, found `Record`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> src\database\operations\background_task_ops.rs:205:8
    |
205 |     fn record_to_task(record: sqlx::sqlite::SqliteRow) -> 
Result<Task> {
    |        ^^^^^^^^^^^^^^ -------------------------------

error[E0716]: temporary value dropped while borrowed
   --> src\database\operations\background_task_ops.rs:195:13
    |
189 |           let result = sqlx::query!(
    |  ______________________-
190 | |             r#"
191 | |             DELETE FROM background_tasks 
192 | |             WHERE status IN ('completed', 'failed', 'cancelled') 
...   |
195 | |             format!("-{} days", days)
    | |             ^^^^^^^^^^^^^^^^^^^^^^^^^ creates a temporary value 
which is freed while still in use
196 | |         )
    | |_________- temporary value is freed at the end of this statement
197 |           .execute(&*pool)
    |            ------- borrow later used by call
    |
    = note: consider using a `let` binding to create a longer lived value
    = note: this error originates in the macro `format` (in Nightly 
builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `parse` found for enum 
`std::option::Option` in the current scope
    --> src\database\operations\performance_metric_ops.rs:381:34
     |
381  |                 Some(val) => val.parse().unwrap_or(30),
     |                                  ^^^^^ method not found in 
`Option<String>`
     |
note: the method `parse` exists on the type `std::string::String`
    --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\li
b/rustlib/src/rust\library\core\src\str\mod.rs:2601:5
     |
2601 |     pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `std::string::String` 
value, panicking if the value is an `Option::None`
     |
381  |                 Some(val) => 
val.expect("REASON").parse().unwrap_or(30),
     |                                 +++++++++++++++++

error[E0308]: mismatched types
    --> src\database\operations\plot_thread_ops.rs:255:50
     |
255  |             
plot_thread.characters_involved.push(character_id.to_string());
     |                                             ---- 
^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `String`
     |                                             |
     |                                             arguments to this 
method are incorrect
     |
note: method defined here
    --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\li
b/rustlib/src/rust\library\alloc\src\string.rs:1403:12
     |
1403 |     pub fn push(&mut self, ch: char) {
     |            ^^^^
note: you might have meant to use method `push_str`
    --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\li
b/rustlib/src/rust\library\alloc\src\string.rs:1111:5
     |
1111 |     pub fn push_str(&mut self, string: &str) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `char` with `&str`
   --> src\database\operations\plot_thread_ops.rs:266:56
    |
266 |         plot_thread.characters_involved.retain(|id| id != 
character_id);
    |                                                        ^^ no 
implementation for `char == &str`
    |
    = help: the trait `PartialEq<&str>` is not implemented for `char`
    = help: the following other types implement trait `PartialEq<Rhs>`:
              `char` implements 
`PartialEq<potential_utf::uchar::PotentialCodePoint>`
              `char` implements `PartialEq`

error[E0308]: mismatched types
    --> src\database\operations\plot_thread_ops.rs:277:49
     |
277  |             
plot_thread.documents_involved.push(document_id.to_string());
     |                                            ---- 
^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `String`
     |                                            |
     |                                            arguments to this 
method are incorrect
     |
note: method defined here
    --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\li
b/rustlib/src/rust\library\alloc\src\string.rs:1403:12
     |
1403 |     pub fn push(&mut self, ch: char) {
     |            ^^^^
note: you might have meant to use method `push_str`
    --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\li
b/rustlib/src/rust\library\alloc\src\string.rs:1111:5
     |
1111 |     pub fn push_str(&mut self, string: &str) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `char` with `&str`
   --> src\database\operations\plot_thread_ops.rs:288:55
    |
288 |         plot_thread.documents_involved.retain(|id| id != 
document_id);
    |                                                       ^^ no 
implementation for `char == &str`
    |
    = help: the trait `PartialEq<&str>` is not implemented for `char`
    = help: the following other types implement trait `PartialEq<Rhs>`:
              `char` implements 
`PartialEq<potential_utf::uchar::PotentialCodePoint>`
              `char` implements `PartialEq`

warning: unused variable: `severity`
   --> src\database\operations\series_consistency_ops.rs:445:9
    |
445 |         severity: ConflictSeverity,
    |         ^^^^^^^^ help: if this is intentional, prefix it with an 
underscore: `_severity`

warning: unused variable: `severity`
   --> src\database\operations\series_consistency_ops.rs:449:47
    |
449 |             .filter(|c| matches!(&c.severity, severity))
    |                                               ^^^^^^^^ help: if 
this is intentional, prefix it with an underscore: `_severity`

error[E0277]: the trait bound `std::string::String: 
From<std::option::Option<std::string::String>>` is not satisfied
   --> src\database\backup.rs:157:23
    |
157 |           let backups = sqlx::query_as!(
    |  _______________________^
158 | |             BackupRecord,
159 | |             r#"
160 | |             SELECT id, filename, created_at, is_auto, comment
...   |
163 | |             "#,
164 | |         )
    | |_________^ the trait 
`From<std::option::Option<std::string::String>>` is not implemented for 
`std::string::String`
    |
    = help: the following other types implement trait `From<T>`:
              `std::string::String` implements `From<&mut str>`
              `std::string::String` implements 
`From<&std::string::String>`
              `std::string::String` implements `From<&str>`
              `std::string::String` implements `From<AssetKey>`
              `std::string::String` implements `From<Box<str>>`
              `std::string::String` implements `From<Cow<'_, str>>`
              `std::string::String` implements `From<Uuid>`
              `std::string::String` implements `From<char>`
            and 8 others
    = note: required for `std::option::Option<std::string::String>` to 
implement `Into<std::string::String>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0277]: the trait bound `DateTime<Utc>: From<NaiveDateTime>` is not 
satisfied
   --> src\database\backup.rs:157:23
    |
157 |           let backups = sqlx::query_as!(
    |  _______________________^
158 | |             BackupRecord,
159 | |             r#"
160 | |             SELECT id, filename, created_at, is_auto, comment
...   |
163 | |             "#,
164 | |         )
    | |_________^ the trait `From<NaiveDateTime>` is not implemented for 
`DateTime<Utc>`
    |
    = help: the following other types implement trait `From<T>`:
              `DateTime<Utc>` implements `From<DateTime<FixedOffset>>`
              `DateTime<Utc>` implements `From<DateTime<chrono::Local>>`
              `DateTime<Utc>` implements `From<SystemTime>`
    = note: required for `NaiveDateTime` to implement 
`Into<DateTime<Utc>>`
    = note: this error originates in the macro 
`$crate::sqlx_macros::expand_query` which comes from the expansion of the 
macro `sqlx::query_as` (in Nightly builds, run with -Z macro-backtrace 
for more info)

error[E0308]: mismatched types
   --> src\database\backup.rs:337:45
    |
337 |             Self::delete_backup(app_handle, &backup.id).await?;
    |             -------------------             ^^^^^^^^^^ expected 
`&str`, found `&Option<String>`
    |             |
    |             arguments to this function are incorrect
    |
    = note: expected reference `&str`
               found reference `&std::option::Option<std::string::String>`
note: associated function defined here
   --> src\database\backup.rs:206:18
    |
206 |     pub async fn delete_backup(app_handle: &AppHandle, backup_id: 
&str) -> Result<()> {
    |                  ^^^^^^^^^^^^^                         
---------------

error[E0597]: `stack_position_str` does not live long enough
   --> src\models\ai_card.rs:191:27
    |
190 |             let stack_position_str = stack_position.to_string();
    |                 ------------------ binding `stack_position_str` 
declared here
191 |             bindings.push(&stack_position_str);
    |                           ^^^^^^^^^^^^^^^^^^^ borrowed value does 
not live long enough
192 |         }
    |         - `stack_position_str` dropped here while still borrowed
...
196 |             bindings.push(tags.as_str());
    |             -------- borrow later used here

warning: unused variable: `settings`
  --> src\ai\write_processor.rs:53:9
   |
53 |         settings: &WriteSettings,
   |         ^^^^^^^^ help: if this is intentional, prefix it with an 
underscore: `_settings`

error[E0308]: mismatched types
   --> src\ai\write_processor.rs:209:16
    |
209 |         if let Some(content) = document.content {
    |                ^^^^^^^^^^^^^   ---------------- this expression has 
type `std::string::String`
    |                |
    |                expected `String`, found `Option<_>`
    |
    = note: expected struct `std::string::String`
                 found enum `std::option::Option<_>`

error[E0308]: mismatched types
   --> src\ai\write_processor.rs:269:20
    |
269 |             if let Some(content) = document.content {
    |                    ^^^^^^^^^^^^^   ---------------- this expression 
has type `std::string::String`
    |                    |
    |                    expected `String`, found `Option<_>`
    |
    = note: expected struct `std::string::String`
                 found enum `std::option::Option<_>`

error[E0382]: borrow of moved value: `task_id`
    --> src\background\mod.rs:505:66
     |
463  | ...   let (task_type, task_id) = {
     |                       -------
     |                       |
     |                       this reinitialization might get skipped
     |                       move occurs because `task_id` has type 
`std::string::String`, which does not implement the `Copy` trait
...
471  | ...   for processor in processors_read.iter() {
     |       --------------------------------------- inside of this loop
...
485  | ...           tokio::spawn(async move {
     |                            ---------- value moved here
...
489  | ...                   if let Err(e2) = 
task_queue_clone.complete_task(&task_id, false, 
Some(e.to_string())).await {
     |                                                                    
    ------- variable moved due to use in coroutine
...
505  | ...       if let Err(e) = task_queue.complete_task(&task_id, 
false, Some("No processor found for task type".to_string())).await {
     |                                                    ^^^^^^^^ value 
borrowed here after move
     |
     = note: borrow occurs due to deref coercion to `str`
note: deref defined here
    --> C:\Users\jjgor\.rustup\toolchains\stable-x86_64-pc-windows-msvc\li
b/rustlib/src/rust\library\alloc\src\string.rs:2703:5
     |
2703 |     type Target = str;
     |     ^^^^^^^^^^^

error[E0308]: mismatched types
  --> src\background\ai_processor.rs:72:17
   |
72 |                 format!("AI generation failed: {}", e)
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 
`&str`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly 
builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `emit` found for struct `AppHandle` in the 
current scope
   --> src\background\ai_processor.rs:79:41
    |
79  |         if let Err(e) = self.app_handle.emit(
    |                         ----------------^^^^
    |
   ::: C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:6
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |      ---- the method is available for `AppHandle` here
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `exit` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\app.rs:534:3
    |
534 |   pub fn exit(&self, exit_code: i32) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: trait `Emitter` which provides `emit` is implemented but not in 
scope; perhaps you want to import it
    |
4   + use tauri::Emitter;
    |

warning: unused variable: `api_key`
  --> src\security\api_keys.rs:36:61
   |
36 |     pub async fn save_api_key(&self, provider: ApiProvider, api_key: 
&str) -> Result<(), StoryWeaverError> {
   |                                                             ^^^^^^^ 
help: if this is intentional, prefix it with an underscore: `_api_key`

warning: unused variable: `key`
  --> src\security\api_keys.rs:37:13
   |
37 |         let key = match provider {
   |             ^^^ help: if this is intentional, prefix it with an 
underscore: `_key`

warning: unused variable: `key`
  --> src\security\api_keys.rs:57:13
   |
57 |         let key = match provider {
   |             ^^^ help: if this is intentional, prefix it with an 
underscore: `_key`

warning: unused variable: `key`
  --> src\security\api_keys.rs:72:13
   |
72 |         let key = match provider {
   |             ^^^ help: if this is intentional, prefix it with an 
underscore: `_key`

warning: use of deprecated associated function 
`chrono::DateTime::<Tz>::from_utc`: Use TimeZone::from_utc_datetime() or 
DateTime::from_naive_utc_and_offset instead
   --> src\security\audit.rs:180:74
    |
180 |                     created_at: row.created_at.map(|dt| 
DateTime::<Utc>::from_utc(dt, Utc)),
    |                                                                     
     ^^^^^^^^
    |
    = note: `#[warn(deprecated)]` on by default

error[E0308]: mismatched types
    --> src\security\privacy.rs:177:66
     |
177  |             let settings: PrivacySettings = 
serde_json::from_str(&row.value)
     |                                             -------------------- 
^^^^^^^^^^ expected `&str`, found `&Option<String>`
     |                                             |
     |                                             arguments to this 
function are incorrect
     |
     = note: expected reference `&str`
                found reference 
`&std::option::Option<std::string::String>`
note: function defined here
    --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557
f\serde_json-1.0.142\src\de.rs:2697:8
     |
2697 | pub fn from_str<'a, T>(s: &'a str) -> Result<T>
     |        ^^^^^^^^

error[E0277]: async commands that contain references as inputs must 
return a `Result`
  --> src\commands\story_bible_ai.rs:80:6
   |
80 | ) -> CommandResponse<AIGenerationResponse> {
   |      ^^^^^^^^^^^^^^^ the trait 
`story_bible_ai::_::AsyncCommandMustReturnResult` is not implemented for 
`CommandResponse<AIGenerationResponse>`
   |
   = help: the trait `story_bible_ai::_::AsyncCommandMustReturnResult` is 
implemented for `std::result::Result<A, B>`
   = note: required for the cast from 
`&CommandResponse<AIGenerationResponse>` to `&dyn 
story_bible_ai::_::AsyncCommandMustReturnResult`

error[E0277]: async commands that contain references as inputs must 
return a `Result`
   --> src\commands\story_bible_ai.rs:151:6
    |
151 | ) -> CommandResponse<Vec<String>> {
    |      ^^^^^^^^^^^^^^^ the trait 
`story_bible_ai::_::AsyncCommandMustReturnResult` is not implemented for 
`CommandResponse<Vec<std::string::String>>`
    |
    = help: the trait `story_bible_ai::_::AsyncCommandMustReturnResult` 
is implemented for `std::result::Result<A, B>`
    = note: required for the cast from 
`&CommandResponse<Vec<std::string::String>>` to `&dyn 
story_bible_ai::_::AsyncCommandMustReturnResult`

error[E0277]: async commands that contain references as inputs must 
return a `Result`
  --> src\commands\background_commands.rs:22:6
   |
22 | ) -> CommandResponse<String> {
   |      ^^^^^^^^^^^^^^^ the trait 
`background_commands::_::AsyncCommandMustReturnResult` is not implemented 
for `CommandResponse<std::string::String>`
   |
   = help: the trait 
`background_commands::_::AsyncCommandMustReturnResult` is implemented for 
`std::result::Result<A, B>`
   = note: required for the cast from 
`&CommandResponse<std::string::String>` to `&dyn 
background_commands::_::AsyncCommandMustReturnResult`

error[E0277]: async commands that contain references as inputs must 
return a `Result`
   --> src\commands\background_commands.rs:160:6
    |
160 | ) -> CommandResponse<bool> {
    |      ^^^^^^^^^^^^^^^ the trait 
`background_commands::_::AsyncCommandMustReturnResult` is not implemented 
for `CommandResponse<bool>`
    |
    = help: the trait 
`background_commands::_::AsyncCommandMustReturnResult` is implemented for 
`std::result::Result<A, B>`
    = note: required for the cast from `&CommandResponse<bool>` to `&dyn 
background_commands::_::AsyncCommandMustReturnResult`

error[E0308]: mismatched types
  --> src\commands\style_examples.rs:42:22
   |
42 |             user_id: style_example.user_id,
   |                      ^^^^^^^^^^^^^^^^^^^^^ expected `String`, found 
`Option<String>`
   |
   = note: expected struct `std::string::String`
                found enum `std::option::Option<std::string::String>`
help: consider using `Option::expect` to unwrap the 
`std::option::Option<std::string::String>` value, panicking if the value 
is an `Option::None`
   |
42 |             user_id: style_example.user_id.expect("REASON"),
   |                                           +++++++++++++++++

error[E0599]: no method named `emit_to` found for reference `&AppHandle` 
in the current scope
   --> src\commands\sync_commands.rs:78:10
    |
77  | /     app_handle
78  | |         .emit_to("main", "document_updated", payload)
    | |_________-^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `emit` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:3
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^
help: trait `Emitter` which provides `emit_to` is implemented but not in 
scope; perhaps you want to import it
    |
1   + use tauri::Emitter;
    |

error[E0599]: no method named `emit_to` found for reference `&AppHandle` 
in the current scope
   --> src\commands\sync_commands.rs:98:10
    |
97  | /     app_handle
98  | |         .emit_to("main", "settings_updated", payload)
    | |_________-^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `emit` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:3
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^
help: trait `Emitter` which provides `emit_to` is implemented but not in 
scope; perhaps you want to import it
    |
1   + use tauri::Emitter;
    |

error[E0599]: no method named `emit_to` found for reference `&AppHandle` 
in the current scope
   --> src\commands\sync_commands.rs:131:10
    |
130 | /     app_handle
131 | |         .emit_to("main", "card_updated", payload)
    | |_________-^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `emit` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:3
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^
help: trait `Emitter` which provides `emit_to` is implemented but not in 
scope; perhaps you want to import it
    |
1   + use tauri::Emitter;
    |

error[E0599]: no method named `emit_to` found for reference `&AppHandle` 
in the current scope
   --> src\commands\sync_commands.rs:167:10
    |
166 | /     app_handle
167 | |         .emit_to("main", "project_updated", payload)
    | |_________-^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `emit` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:3
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^
help: trait `Emitter` which provides `emit_to` is implemented but not in 
scope; perhaps you want to import it
    |
1   + use tauri::Emitter;
    |

error[E0599]: no method named `emit_to` found for reference `&AppHandle` 
in the current scope
   --> src\commands\sync_commands.rs:193:10
    |
192 | /     app_handle
193 | |         .emit_to("main", "folder_updated", payload)
    | |_________-^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `emit` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:3
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^
help: trait `Emitter` which provides `emit_to` is implemented but not in 
scope; perhaps you want to import it
    |
1   + use tauri::Emitter;
    |

error[E0599]: no method named `emit_to` found for reference `&AppHandle` 
in the current scope
   --> src\commands\sync_commands.rs:224:10
    |
223 | /     app_handle
224 | |         .emit_to("main", "series_updated", payload)
    | |_________-^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `emit` with a similar name, but with different 
arguments
   --> C:\Users\jjgor\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f
\tauri-2.7.0\src\lib.rs:961:3
    |
961 |   fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> 
Result<()> {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^
help: trait `Emitter` which provides `emit_to` is implemented but not in 
scope; perhaps you want to import it
    |
1   + use tauri::Emitter;
    |

error[E0599]: no method named `path_resolver` found for reference 
`&AppHandle` in the current scope
  --> src\security\encryption.rs:84:35
   |
84 |     let app_data_dir = app_handle.path_resolver().app_data_dir()
   |                                   ^^^^^^^^^^^^^ method not found in 
`&AppHandle`

warning: unused import: `AIProvider`
 --> src\background\ai_processor.rs:4:28
  |
4 | use crate::ai::{AIContext, AIProvider, AIProviderManager};
  |                            ^^^^^^^^^^

warning: unused import: `Manager`
 --> src\security\api_keys.rs:9:24
  |
9 | use tauri::{AppHandle, Manager};
  |                        ^^^^^^^

warning: unused variable: `context`
   --> src\ai\openai.rs:145:36
    |
145 |     fn build_system_message(&self, context: &AIContext) -> 
ChatMessage {
    |                                    ^^^^^^^ help: if this is 
intentional, prefix it with an underscore: `_context`

warning: unused variable: `context`
   --> src\ai\claude.rs:126:36
    |
126 |     fn build_system_message(&self, context: &AIContext) -> String {
    |                                    ^^^^^^^ help: if this is 
intentional, prefix it with an underscore: `_context`

warning: unused variable: `text`
   --> src\ai\claude.rs:375:40
    |
375 |     async fn generate_embedding(&self, text: &str) -> 
Result<Vec<f32>> {
    |                                        ^^^^ help: if this is 
intentional, prefix it with an underscore: `_text`

warning: unused variable: `text`
   --> src\ai\gemini.rs:398:40
    |
398 |     async fn generate_embedding(&self, text: &str) -> 
Result<Vec<f32>> {
    |                                        ^^^^ help: if this is 
intentional, prefix it with an underscore: `_text`

Some errors have detailed explanations: E0061, E0107, E0277, E0308, 
E0382, E0559, E0597, E0599, E0716.
For more information about an error, try `rustc --explain E0061`.
warning: `storyweaver` (lib) generated 87 warnings
error: could not compile `storyweaver` (lib) due to 211 previous errors; 
87 warnings emitted
